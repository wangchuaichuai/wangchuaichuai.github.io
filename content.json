{"meta":{"title":"王小欣の博客","subtitle":"王小欣の博客","description":"本科 | 软件工程 | 嵌入式开发及前端开发","author":"王小欣","url":"https://wangchuaichuai.github.io","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2021-10-31T11:35:57.138Z","comments":true,"path":"404.html","permalink":"https://wangchuaichuai.github.io/404.html","excerpt":"","text":""},{"title":"about","date":"2021-10-31T16:00:00.000Z","updated":"2021-11-03T09:27:23.617Z","comments":true,"path":"about/index.html","permalink":"https://wangchuaichuai.github.io/about/index.html","excerpt":"","text":""},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2021-10-31T11:35:57.157Z","comments":true,"path":"List/index.html","permalink":"https://wangchuaichuai.github.io/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-10-31T11:35:57.271Z","comments":true,"path":"archives/index.html","permalink":"https://wangchuaichuai.github.io/archives/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2021-10-31T11:35:57.274Z","comments":true,"path":"friends/index.html","permalink":"https://wangchuaichuai.github.io/friends/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-10-31T16:00:00.000Z","updated":"2021-11-03T09:26:51.152Z","comments":true,"path":"categories/index.html","permalink":"https://wangchuaichuai.github.io/categories/index.html","excerpt":"","text":""},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2021-10-31T11:35:57.272Z","comments":true,"path":"census/index.html","permalink":"https://wangchuaichuai.github.io/census/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-10-24T16:00:00.000Z","updated":"2021-10-31T15:33:01.780Z","comments":true,"path":"contact/index.html","permalink":"https://wangchuaichuai.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 王欣の友链信息 博客名称: 王欣の博客 博客网址: https://www.wx-blog.cn 博客头像: https://s1.ax1x.com/2020/05/17/YRWsYT.png 博客介绍: The harder you work, the luckier you will be"},{"title":"资源分享","date":"2021-10-19T08:40:27.000Z","updated":"2021-11-03T10:34:57.376Z","comments":true,"path":"resource/index.html","permalink":"https://wangchuaichuai.github.io/resource/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2021-10-31T11:35:57.276Z","comments":true,"path":"tags/index.html","permalink":"https://wangchuaichuai.github.io/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2021-10-31T11:35:57.146Z","updated":"2021-10-31T11:35:57.146Z","comments":true,"path":"List/galleries/index.html","permalink":"https://wangchuaichuai.github.io/List/galleries/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2021-10-31T11:35:57.157Z","comments":true,"path":"List/movies/index.html","permalink":"https://wangchuaichuai.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2020-07-19T08:40:27.000Z","updated":"2021-11-03T10:35:10.946Z","comments":true,"path":"List/music/index.html","permalink":"https://wangchuaichuai.github.io/List/music/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-10-31T11:35:57.158Z","comments":true,"path":"List/tools/index.html","permalink":"https://wangchuaichuai.github.io/List/tools/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2021-10-31T11:35:57.147Z","updated":"2021-10-31T11:35:57.147Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"https://wangchuaichuai.github.io/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2021-11-03T10:35:27.661Z","updated":"2021-10-31T11:35:57.149Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"https://wangchuaichuai.github.io/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2021-10-31T11:35:57.149Z","updated":"2021-10-31T11:35:57.149Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"https://wangchuaichuai.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2021-10-31T11:35:57.151Z","updated":"2021-10-31T11:35:57.151Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"https://wangchuaichuai.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2021-10-31T11:35:57.151Z","updated":"2021-10-31T11:35:57.151Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"https://wangchuaichuai.github.io/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2021-10-31T11:35:57.155Z","updated":"2021-10-31T11:35:57.155Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"https://wangchuaichuai.github.io/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2021-10-31T11:35:57.153Z","updated":"2021-10-31T11:35:57.153Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"https://wangchuaichuai.github.io/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2021-10-31T11:35:57.150Z","updated":"2021-10-31T11:35:57.150Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"https://wangchuaichuai.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2021-10-31T11:35:57.154Z","updated":"2021-10-31T11:35:57.154Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"https://wangchuaichuai.github.io/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2021-10-31T11:35:57.154Z","updated":"2021-10-31T11:35:57.154Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"https://wangchuaichuai.github.io/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2021-10-31T11:35:57.155Z","updated":"2021-10-31T11:35:57.155Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"https://wangchuaichuai.github.io/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2021-10-31T11:35:57.156Z","updated":"2021-10-31T11:35:57.156Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"https://wangchuaichuai.github.io/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""}],"posts":[{"title":"vue3+eslint遇到 The template root requires exactly one element.eslintvue/no-multiple-template-root ...","slug":"vue3+eslint遇到问题","date":"2022-08-09T03:27:00.000Z","updated":"2022-08-10T01:50:42.299Z","comments":true,"path":"posts/1d5b7024.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/1d5b7024.html","excerpt":"","text":"vue3+eslint遇到 The template root requires exactly one element.eslintvue/no-multiple-template-root 解决方案 slint配置文件，我这里是 .eslintrc.js xtends 中的 ‘plugin:vue/essential’，改成’plugin:vue/vue3-essential’ 搞定","categories":[{"name":"问题篇","slug":"问题篇","permalink":"https://wangchuaichuai.github.io/categories/%E9%97%AE%E9%A2%98%E7%AF%87/"},{"name":"配置篇","slug":"问题篇/配置篇","permalink":"https://wangchuaichuai.github.io/categories/%E9%97%AE%E9%A2%98%E7%AF%87/%E9%85%8D%E7%BD%AE%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"},{"name":"eslint","slug":"eslint","permalink":"https://wangchuaichuai.github.io/tags/eslint/"}],"author":"王小欣"},{"title":"threejs性能优化与GPU优化","slug":"threejs性能优化与GPU优化","date":"2022-08-05T09:57:00.000Z","updated":"2022-08-05T09:59:05.115Z","comments":true,"path":"posts/6795e18f.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/6795e18f.html","excerpt":"","text":"three.js是目前国内开发Web3D应用最多的第三方库，它提供了非常多的3D显示功能。在使用的时候，虽然three.js 本身做了优化，但是在较大分辨率下，加载较大或者较多模型时会出现，帧率会越低，给人感觉就越卡，因此性能方面的优化对提高视觉体验有着积极影响。以下是我在项目（vue+threejs）开发结合度娘总结的一些思路，希望能有所帮助。 合理执行渲染方法因为默认情况下requestAnimationFrame（）每秒执行60次，如果在里面加个for循环，代码效率就会严重影响，同时还要减少浮点计算，系统对浮点计算开支比较大，尽量写成小数乘法。 在一些特定的应用中没有必要保持Threejs渲染频率为60FPS，那么可以通过Threejs渲染时间判断来控制Threejs渲染频率，比如设置为30FPS。 下面代码通过时钟对象.Clock的.getDelta()方法获得threejs两帧渲染时间间隔，然后通过时间判断来控制渲染器渲染方法.render()每秒执行次数： // 创建一个时钟对象Clock var clock = new THREE.Clock(); // 设置渲染频率为30FBS，也就是每秒调用渲染器render方法大约30次 var FPS = 30; var renderT = 1 / FPS; //单位秒 间隔多长时间渲染渲染一次 // 声明一个变量表示render()函数被多次调用累积时间 // 如果执行一次renderer.render，timeS重新置0 var timeS = 0; function render() { requestAnimationFrame(render); //.getDelta()方法获得两帧的时间间隔 var T = clock.getDelta(); timeS = timeS + T; // requestAnimationFrame默认调用render函数60次，通过时间判断，降低renderer.render执行频率 if (timeS &gt; renderT) { // 控制台查看渲染器渲染方法的调用周期，也就是间隔时间是多少 console.log(`调用.render时间间隔`,timeS*1000+'毫秒'); renderer.render(scene, camera); //执行渲染操作 ... //renderer.render每执行一次，timeS置0 timeS = 0; } } render(); 共享几何体和材质不同的网格模型如果可以共享几何体或材质，最好采用共享的方式，如果两个网格模型无法共享几何体或材质，自然不需要共享，比如两个网格模型的材质颜色不同，这种情况下，一般要分别为网格模型创建一个材质对象 相同或者相似类型的对象生成时多使用clone()方法，例如生成多个类似的立方体，推荐使用group，结合clone()方法，代码如下 const group = new THREE.Group() const bar = new THREE.Mesh(barGeo, material) bar.scale.set(0.3, 0.3, 0.3) for (let i = 0; i &lt; 80; i++) { const cBar = bar.clone() group.add(cBar) } 使用性能检测插件（stats.js）监测页面性能// 引入stats.js import Stats from 'three/examples/js/libs/stats.min.js' const stats = new Stats() // 设置stats样式 stats.dom.style.position = 'absolute'; stats.dom.style.top = '0px'; document.body.appendChild(stats.dom); 在渲染函数中需要添加如下代码： function Animate() { requestAnimationFrame(Animate); Render(); } function Render() { // 更新stats stats.update(); render.render(scene,camera); } 对粒子群进行转换，而不是每个粒子使用THREE.Sprite时，可以更好地控制单个粒子，但是当使用大量的粒子的时候，这个方法的性能会降低，并且会更复杂。此时可以使用THREE.SpriteCloud，可以轻松地管理大量的粒子，进行整体操作，此时对单个粒子的控制能力会减弱。 模型的面越少越好，模型过于细致会增加渲染开销three场景导入模型时，可以在保证最低清晰度的时候，降低模型的复杂度，面越多，模型越大，加载所需开销就越大 分时加载调查显示100ms内的响应能让用户感觉非常流畅。50ms是 Nicholas 针对 JavaScript 得出的最佳经验值，setTimeout 延时25ms，25ms 保证主流浏览器都顺畅，可以使用类似的方法来优化three.js程序。 初始化方法以及渲染方法可以适当添加延时以分散同时渲染的压力。 当存在多个模型动画时，根据实际情况可以将多个动画拆分，再可以对每个动画requestAnimationFrame分别设置渲染频率。 页面销毁时手动调用dispose方法，清除延时beforeDestroy () { clearTimeout() try { this.scene.clear() this.renderer.dispose() this.renderer.forceContextLoss() this.renderer.content = null // cancelAnimationFrame(animationID) // 去除animationFrame const gl = this.renderer.domElement.getContext('webgl') gl &amp;&amp; gl.getExtension('WEBGL_lose_context').loseContext() } catch (e) { console.log(e) } } 一个网格模型Mesh是包含几何体geometry和材质对象Material的，几何体geometry本质上就是顶点数据，Three.js通过WebGL渲染器解析几何体的时候会调用WebGL API创建顶点缓冲区来存储顶点数据。 如果仅仅执行scene.remove(Mesh)只是把网格模型从场景对象的.children属性中删除，解析网格模型Mesh几何体的顶点数据通过WebGL API创建的顶点缓冲区占用的内存并不会释放。 从内存中删除对象或者删除几何体时不要忘记调用以下方法，因为可能导致内存泄漏 geometry.dispose() // 删除几何体 material.dispose() // 删除材质 加载/渲染时间长的添加loading效果当加载较大模型或者渲染比较复杂的模型时，页面会有较长时间卡顿，影响用户体验。可以添加loading效果，降低用户等待焦虑。 渲染3D的显卡建议设置为独立显卡在性能和功耗方面，集成显卡具有一般性能的特点，但基本可以满足一些日常应用，与独立显卡相比，热功耗低。虽然独立显卡的性能很强，但其热量和功耗都比较高。独立显卡在三维性能上优于集成显卡。 修改浏览器GUP加速相关设置Chrome浏览器：chrome://flags/#enable-gpu-rasterization GPU rasterization 设置为Enabled chrome://flags/#ignore-gpu-blocklist Override software rendering list 设置为Enabled chrome://flags/#enable-zero-copy Zero-copy rasterizer 设置为Enabled Firefox浏览器：要想GPU加速文本的功能，不仅仅要下载最新的nightlyBuild火狐(Minefield)之外，还要通过以下方法操作才能开启该功能： 进入about:config配置页面并搜索gfx.font 双击gfx.font_rendering.directwrite.enabled打开这项功能; 点右键新建一个integer，命名为mozilla.widget.render-mode; 为该integer赋值为6; 重启浏览器。 Edge（win10）浏览器： 使用 Windows + I 快捷键打开「Windows 设置」——导航到「系统」——「显示」选项页 点击「多显示器设置」下的「图形设置」链接，打开「图形设置」专属配置页面 在「图形性能首选项」的下拉列表中选择「通用应用」——再在「选择应用」下拉列表中添加 Microsoft Edge 浏览器。 添加好之后点击已添加的 Microsoft Edge，再点击「选项」按钮 在弹出的「图形规格」选项卡中可以看到当前系统中的所有显卡，选择「高性能」并「保存」即可指定 Microsoft Edge 永久使用使用性能最高的 GPU。 完成上述操作步骤后，再重新启动下 Microsoft Edge，它现在就应该会使用 PC 的独立显卡进行渲染任务了。 ​ tips：用threejs做大分辨率下的显示应用时，需要考虑3D渲染的显卡性能以及显卡最大分辨率与显示屏分辨率的对比情况，如果在做了相关优化之后GPU的占用率仍然偏高，页面动效卡顿，三维效果不理想，甚至出现有时候因GPU超负荷而是电脑卡死的情况，这时候就需要考虑升级显卡配置了。","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"学习篇","slug":"技术篇/学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"threejs","slug":"threejs","permalink":"https://wangchuaichuai.github.io/tags/threejs/"},{"name":"3D可视化","slug":"3D可视化","permalink":"https://wangchuaichuai.github.io/tags/3D%E5%8F%AF%E8%A7%86%E5%8C%96/"}],"author":"王小欣"},{"title":"使用bcryptjs对nest中的密码进行加密","slug":"threejs着色器","date":"2022-07-06T04:37:00.000Z","updated":"2022-07-06T00:39:18.613Z","comments":true,"path":"posts/a0db594.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/a0db594.html","excerpt":"","text":"threejs着色器—uv动画UV动画的实现方式，一种是通过Texture偏移属性offset实现UV动画，另一种方式是通过着色器代码的方式实现UV动画。 Texture偏移属性offset实现UV动画.wrapS定义了纹理如何水平包裹，并对应于UV映射中的U. .wrapT这定义了纹理垂直包裹的方式，与UV映射中的V相对应. var texture = textureLoader.load('./texture.png'); // 设置重复的作用是：能够让一个效果循环 texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping; 渲染函数周期性执行的过程中，Three.js纹理对象Texture的偏移属性offset两个分量x和y递增或递减。 function render() { // 每次渲染对纹理对象进行偏移，不停的偏移纹理，就产生了动画的效果 texture.offset.x -= 0.001; texture.offset.y += 0.001; group.rotateY(-0.005) renderer.render(scene, camera); requestAnimationFrame(render); } 着色器中uniform变量更新通过自定着色器代码的方式实现UV动画，基本思路就是在片元着色器中声明一个时间变量time，然后在JavaScript代码中更新着色器中的时间变量time。时间变量time变化后，通过vec2 newT= vUv + vec2( -0.02, 0.02 ) * time;改变插值后的纹理坐标vUV，纹理坐标变化了，渲染的时候，纹理采样的结果肯定发生了变化。 片元着色器中声明的一个时间变量time // 声明一个时间变量用来控制UV动画 uniform float time; // 声明一个纹理对象变量 uniform sampler2D texture; // 顶点片元化后有多少个片元就有多少个纹理坐标数据vUv varying vec2 vUv; void main() { vec2 newT= vUv + vec2( -0.02, 0.02 ) * time; //通过偏移后的纹理坐标newT采样像素 gl_FragColor = texture2D( texture, newT ); // 整体透明度增加 gl_FragColor.a *=0.6; } 通过自定义着色器ShaderMaterial的属性.uniforms设置传递给片元着色器中的变量time的值 uniforms: { // 对应片元着色器中的时间变量time time: { value: 0.0 }, }, 在渲染函数中不停地更新ShaderMaterial对象uniforms属性的时间变量time的值，每次执行新的渲染，Threejs系统会自动更新片元着色器中的时间变量time的值。 // 创建一个时钟对象T var T = new THREE.Clock(); // 渲染函数 function render() { // 获得两次渲染的时间间隔deltaTime var deltaTime = T.getDelta(); // 更新uniforms中时间，这样就可以更新着色器中time变量的值 material.uniforms.time.value += deltaTime; renderer.render(scene, camera); requestAnimationFrame(render); }","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"学习篇","slug":"技术篇/学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"threejs","slug":"threejs","permalink":"https://wangchuaichuai.github.io/tags/threejs/"},{"name":"3D","slug":"3D","permalink":"https://wangchuaichuai.github.io/tags/3D/"}],"author":"王小欣"},{"title":"使用bcryptjs对nest中的密码进行加密","slug":"bcryptjs","date":"2022-07-02T04:37:00.000Z","updated":"2022-07-06T00:39:18.607Z","comments":true,"path":"posts/a0db594.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/a0db594.html","excerpt":"","text":"使用bcryptjs对nest中的密码进行加密密码不能以明文形式保存到数据库中，否则数据泄露密码就会被知道。而一般的加密方式由于加密规则固定，很容易被破解，安全系数不高。密码加盐的加密方式，能很好的解决这一点。解决字典攻击的方式 是加盐。 1.bcryptjs是nodejs中比较好的一款加盐(salt)加密的包.2.所谓加盐.就是系统生成一串随机值,然后混入原始密码中,然后按照加密方式生成一串字符串保存在服务器。3.安装 npm install bcryptjs yarn add bcryptjs cnpm install bcryptjs 4.使用 /** * bcryptjs 加密 */ const bcryptjs = require('bcryptjs'); const password = '123456789'; /** * 加密处理 - 同步方法 * bcryptjs.hashSync(data, salt) * - data 要加密的数据 * - slat 用于哈希密码的盐。如果指定为数字，则将使用指定的轮数生成盐并将其使用。推荐 10 */ let hashPassword=bcryptjs.hashSync(password, 10); console.log(hasPwd) // $2a$10$y5WA7lOVpzxVh.pqK3kUzOFZaJZXUMutvb3EG0qocgRxGcKQG36ou /** * 校验 - 使用同步方法 * bcryptjs.compareSync(data, encrypted) * - data 要比较的数据, 使用登录时传递过来的密码 * - encrypted 要比较的数据, 使用从数据库中查询出来的加密过的密码 */ let comparePwd=bcryptjs.compareSync(password,hashPassword); console.log(comparePwd);//true let comparePwd=bcryptjs.compareSync(password,'123456'); console.log(comparePwd);//false","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"学习篇","slug":"技术篇/学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"nestjs","slug":"nestjs","permalink":"https://wangchuaichuai.github.io/tags/nestjs/"},{"name":"nodejs","slug":"nodejs","permalink":"https://wangchuaichuai.github.io/tags/nodejs/"},{"name":"加密","slug":"加密","permalink":"https://wangchuaichuai.github.io/tags/%E5%8A%A0%E5%AF%86/"}],"author":"王小欣"},{"title":"react项目打包后本地运行","slug":"react本地运行","date":"2022-06-16T09:37:00.000Z","updated":"2022-06-16T09:56:19.643Z","comments":true,"path":"posts/3217acb4.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/3217acb4.html","excerpt":"","text":"react项目本地打包后直接运行在打包之前,在package.json中private下(位置任意)添加”homepage”: “./“ 这样在你点击index.html时候路径没有问题不会报错,但是页面可能还是空白的 然后将项目中的引用路由时候的BrowserRouter改为HashRouter,所有用到的地方都要改 然后执行yarn build 或者 npm run build 再点开index.html就不会报错 原因：你必须把build里的文件直接放到应用服务器的根路径下，比如，你的服务器IP是172.16.38.253，应用服务器端口为8080，你应该保证 在服务器下运行和直接打开html文件有什么区别？最直接的区别，很容易注意到，一个是file协议，另一个是http协议。file协议更多的是将该请求视为一个本地资源访问请求，和你使用资源管理器打开是一样的，是纯粹的请求本地文件。而http请求方式则是通过假架设一个web服务器，解析http协议的请求然后向浏览器返回资源信息。我们所开发的html文件最后必定是会以网页的形式部署在服务器上，通过http协议访问，所以我们开发中也尽可能模拟线上环境，架设本地服务器，来避免file协议与http协议实现过程中的某些差异性，如某些API的差异、跨域请求的差异等。举个最容易验证的例子：在页面引入一张绝对路径的图片，即’/image/example.png’，然后分别通过这两种方式打开页面，file协议会将资源请求到根路径，而http协议虽然也会请求到根路径，但是是相对本地架设的服务器的根路径，一般也就是项目文件夹的路径。html是运行于客户端的超文本语言，从安全性上来讲，服务端不能对客户端进行本地操作。即使有一些象cookie这类的本地操作，也是需要进行安全级别设置的。","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"学习篇","slug":"技术篇/学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"react","slug":"react","permalink":"https://wangchuaichuai.github.io/tags/react/"},{"name":"组件","slug":"组件","permalink":"https://wangchuaichuai.github.io/tags/%E7%BB%84%E4%BB%B6/"},{"name":"打包","slug":"打包","permalink":"https://wangchuaichuai.github.io/tags/%E6%89%93%E5%8C%85/"}],"author":"王小欣"},{"title":"css实现图片无限旋转","slug":"css实现图片无限旋转","date":"2022-06-06T04:37:00.000Z","updated":"2022-06-23T01:11:27.137Z","comments":true,"path":"posts/cbf7cc1c.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/cbf7cc1c.html","excerpt":"","text":"css实现图片无限旋转&lt;img src='/路径' /&gt; .imgs{ -webkit-animation:rotateVbtn 5s linear infinite 800ms 0 ease; -moz-animation: rotateVbtn 5s linear infinite 800ms 0 ease; -ms-animation:rotateVbtn 5s linear infinite 800ms 0 ease; animation: rotateVbtn 5s linear infinite 800ms 0 ease; -moz-animation:rotateVbtn 5s linear infinite; -webkit-animation:rotateVbtn 5s linear infinite; -o-animation:rotateVbtn 5s linear infinite; -ms-animation:rotateVbtn 5s linear infinite; animation:rotateVbtn 5s linear infinite; } @-webkit-keyframes rotateVbtn1 {//重复旋转45度，更改成360即可重复旋转 0% { -webkit-transform: rotate(0); -moz-transform: rotate(0); -ms-transform: rotate(0); -o-transform: rotate(0); transform: rotate(0); } 100% { -webkit-transform: rotate(-45deg); -moz-transform: rotate(-45deg); -ms-transform: rotate(-45deg); -o-transform: rotate(-45deg); transform: rotate(-45deg); } }","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"学习篇","slug":"技术篇/学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wangchuaichuai.github.io/tags/css/"}],"author":"王小欣"},{"title":"Error webpack在打包时候报operation not permitted","slug":"webpack打包报错","date":"2022-05-25T02:47:00.000Z","updated":"2022-05-27T02:27:20.569Z","comments":true,"path":"posts/50206a6.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/50206a6.html","excerpt":"","text":"webpack在打包时候报这个错：Error:EPERM:operation not permitted output: { // 输出文件设置为名称+hash filename: 'js/[name].[hash].js', path: path.resolve(__dirname, '../dist'), }, 只需要将..去掉或者.去掉即可解决 正确写法 output: { // 输出文件设置为名称+hash filename: 'js/[name].[hash].js', path: path.resolve(__dirname, '/dist/'), },","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"}],"tags":[{"name":"React","slug":"React","permalink":"https://wangchuaichuai.github.io/tags/React/"},{"name":"hooks","slug":"hooks","permalink":"https://wangchuaichuai.github.io/tags/hooks/"}],"author":"王小欣"},{"title":"ErrorFailed to load parser ‘babel-eslint‘ declared","slug":"babel-eslint错误","date":"2022-05-25T01:47:00.000Z","updated":"2022-05-27T02:27:20.564Z","comments":true,"path":"posts/6d39992.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/6d39992.html","excerpt":"","text":"Error: Failed to load parser ‘babel-eslint‘ declared in ‘node_modules/shallowequal/package.json‘: Ca只需要手动安装 babel-eslintyarn add -D babel-eslint后重启vscode即可解决","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"}],"tags":[{"name":"React","slug":"React","permalink":"https://wangchuaichuai.github.io/tags/React/"},{"name":"hooks","slug":"hooks","permalink":"https://wangchuaichuai.github.io/tags/hooks/"}],"author":"王小欣"},{"title":"根据页面大小网格布局自适应两行或三行","slug":"实现三行三列自适应两行","date":"2022-05-13T01:47:00.000Z","updated":"2022-05-13T01:57:49.668Z","comments":true,"path":"posts/d18909b7.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/d18909b7.html","excerpt":"","text":"根据页面大小网格布局自适应两行或三行 &lt;div class=\"contain1\"&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"contain2\"&gt; &lt;div class=\"item1\"&gt;&lt;/div&gt; &lt;div class=\"item1\"&gt;&lt;/div&gt; &lt;div class=\"item1\"&gt;&lt;/div&gt; &lt;div class=\"item1\"&gt;&lt;/div&gt; &lt;div class=\"item1\"&gt;&lt;/div&gt; &lt;div class=\"item1\"&gt;&lt;/div&gt; &lt;div class=\"item1\"&gt;&lt;/div&gt; &lt;div class=\"item1\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;style type=\"text/css\"&gt; .item1{ width: 300px; height: 100px; background-color: rebeccapurple; margin-left: 10px; margin-top: 10px; } .item{ width: 300px; height: 100px; background-color: aqua; margin-left: 10px; margin-top: 10px; } &lt;/style&gt; 方法1. 使用@media媒体查询 &lt;style type=\"text/css\"&gt; // 使用@media screen 和and连接其定义的最小或者最大的屏幕尺寸，我这里定义大于1366px现实一行4个，小于1366px一行展示三个，如果需要改变列的话，将属性grid-template-columns改成grid-template-rows @media screen and (min-width:0px) { .contain2{ display: grid; grid-template-columns: 33.3% 33.3% 33.3%; } } @media screen and (min-width:1366px) { .contain2{ display: grid; grid-template-columns: 25% 25% 25% 25%; } } &lt;/style&gt; 方法2. 使用grid属性进行自适应 &lt;style&gt; // 使用repeat的auto-fill进行自动填充，然后设置每一块的大小，自己计算一下，我这里设定分界点是1366px，如果大于的话，一个item是300px，稍微给多一点设置margin等间隔能显示出来设置为320px即可 .contain1{ display: grid; grid-template-columns: repeat(auto-fill, 320px) } &lt;/style&gt;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"}],"tags":[{"name":"React","slug":"React","permalink":"https://wangchuaichuai.github.io/tags/React/"},{"name":"hooks","slug":"hooks","permalink":"https://wangchuaichuai.github.io/tags/hooks/"}],"author":"王小欣"},{"title":"在hooks中怎么做类似PureComponent对props的浅比较","slug":"memo与usecallback联合缓存","date":"2022-05-11T07:15:00.000Z","updated":"2022-05-11T09:53:38.289Z","comments":true,"path":"posts/3987f34f.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/3987f34f.html","excerpt":"","text":"在hooks中怎么做类似PureComponent对props的浅比较在类组件中使用PureComponent可以对props进行浅比较在函数式组件中使用memo包裹组件，使用useMemo包裹值，使用useCallback包裹方法，少一个都会使缓存的组件进行更新无法起到缓存组件的作用 class Demo extends React.PureComponent {// class组件 constructor(props) { super(props) this.state = { age: 20 } } conponentDidMount() { fetch('xx').then( res =&gt; { if(res) { this.setState({ age: res.age }) } }) } const setAgeH = () =&gt; {} const setnameH = () =&gt; {} const setAgeH = usecallback( () =&gt; {}, []) const setnameH = usecallback( () =&gt; {}, []) render() { const { age } = this.state return &lt;div&gt; &lt;span&gt;年龄&lt;/span&gt; &lt;span&gt;{{age}}&lt;/span&gt; &lt;/div&gt; } } // hooks const Age = React.memo(({age,setAge}) =&gt; { return &lt;div&gt;{{age}}&lt;/div&gt; }) function Demo() { useEffect( () =&gt; { console.log(fetchInfo) }, [fetchInfo]) const fetchInfo = useCallback ( () =&gt; { fetch('xxx').then( res =&gt; { if(res){ // setAge(res.age) setAge((oldAge) =&gt; { return oldAge + res.age }) } }) }, [name]) return &lt;div&gt; &lt;span&gt;年龄&lt;/span&gt; &lt;span&gt;{{age}}&lt;/span&gt; &lt;Age age={{age}} setAge={{setAgeH}} /&gt; &lt;Name name={{name}} setname={{setnameH}} /&gt; &lt;/div&gt; }","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"}],"tags":[{"name":"React","slug":"React","permalink":"https://wangchuaichuai.github.io/tags/React/"},{"name":"hooks","slug":"hooks","permalink":"https://wangchuaichuai.github.io/tags/hooks/"}],"author":"王小欣"},{"title":"react memo 和 react.fc的使用","slug":"react memo 和 react.fc的使用","date":"2022-05-11T07:15:00.000Z","updated":"2022-05-11T09:53:38.291Z","comments":true,"path":"posts/7fb96dfc.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/7fb96dfc.html","excerpt":"","text":"react memo 和 react.fc的使用1.memo介绍：React.memo 为高阶组件。它与 React.PureComponent 非常相似，但它适用于函数组件，但不适用于 class 组件。如果你的函数组件在给定相同 props 的情况下渲染相同的结果，那么你可以通过将其包装在 React.memo 中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。这意味着在这种情况下，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。React.memo 仅检查 props 变更。如果函数组件被 React.memo 包裹，且其实现中拥有 useState 或 useContext 的 Hook，当 context 发生变化时，它仍会重新渲染。默认情况下其只会对复杂对象做浅层对比，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。 const comp = () =&gt; { return &lt;div&gt;1&lt;/div&gt; } export default React.memo(comp) 总结：包裹函数组件 避免相同prop下的重复渲染，以达到优化效果 2.React.FC介绍： 1.React.FC是函数式组件，是在TypeScript使用的一个泛型，FC就是FunctionComponent的缩写，事实上React.FC可以写成React.FunctionComponent： const App: React.FunctionComponent&lt;{ message: string }&gt; = ({ message }) =&gt; ( &lt;div&gt;{message}&lt;/div&gt; ); 2.React.FC 包含了 PropsWithChildren 的泛型，不用显式的声明 props.children 的类型。React.FC&lt;&gt; 对于返回类型是显式的，而普通函数版本是隐式的（否则需要附加注释）。3.React.FC提供了类型检查和自动完成的静态属性：displayName，propTypes和defaultProps（注意：defaultProps与React.FC结合使用会存在一些问题）。 ```reactinterface IProps { name: string phone: number}const App: React.FC = (props: PropsWithChildren) =&gt; { const { name, phone } = props return { name }} 使用：总结：React.FC 表示使用类型检查并且表示是函数式组件","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"}],"tags":[{"name":"React","slug":"React","permalink":"https://wangchuaichuai.github.io/tags/React/"},{"name":"hooks","slug":"hooks","permalink":"https://wangchuaichuai.github.io/tags/hooks/"}],"author":"王小欣"},{"title":"useEffect使用定时器出现重复问题","slug":"useEffect使用return清楚定时器","date":"2022-05-08T07:15:00.000Z","updated":"2022-05-08T07:20:17.612Z","comments":true,"path":"posts/1e589684.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/1e589684.html","excerpt":"","text":"useEffect使用定时器出现重复问题react中设置定时器，最后需要将定时器清理，否则下次会出现多次调用的问题使用useEffect来模拟componentWillUnmount生命周期来进行 function Timer() { let [time, setTime] = useState(5); useEffect(() =&gt; { let timer = setInterval(() =&gt; { setTime(time - 1); }, 1000) return () =&gt; clearInterval(timer); }, ); return &lt;div&gt;{time}&lt;/div&gt; }","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"}],"tags":[{"name":"React","slug":"React","permalink":"https://wangchuaichuai.github.io/tags/React/"},{"name":"hooks","slug":"hooks","permalink":"https://wangchuaichuai.github.io/tags/hooks/"}],"author":"王小欣"},{"title":"React中useState两次渲染","slug":"react之usestate渲染两次","date":"2022-05-07T08:37:00.000Z","updated":"2022-05-07T10:12:13.660Z","comments":true,"path":"posts/6556e27c.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/6556e27c.html","excerpt":"","text":"React中useState两次渲染函数式组件使用useState后，console.log打印组件重复渲染问题 index.tsx中的&lt;React.StrictMode&gt;的问题 ReactDOM.render( &lt;React.StrictMode&gt; &lt;App /&gt; &lt;/React.StrictMode&gt; document.getElementById('ROOT') ) 在生产模式下不会出现此问题StrictMode有助于 识别不安全的生命周期 关于使用过字符串 ref API的警告 关于使用废弃的findDOMNode方法的警告 监测意外的副作用 监测过时的context API","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"}],"tags":[{"name":"React","slug":"React","permalink":"https://wangchuaichuai.github.io/tags/React/"},{"name":"hooks","slug":"hooks","permalink":"https://wangchuaichuai.github.io/tags/hooks/"}],"author":"王小欣"},{"title":"使用Yarn创建React项目遇到的问题","slug":"使用Yarn创建React项目遇到的问题","date":"2022-05-06T08:37:00.000Z","updated":"2022-05-07T10:12:13.662Z","comments":true,"path":"posts/7e5ed880.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/7e5ed880.html","excerpt":"","text":"使用Yarn创建React项目遇到的问题yarn create react-app antd-demo yarn create v1.17.3 [1/4] Resolving packages... [2/4] Fetching packages... [3/4] Linking dependencies... [4/4] Building fresh packages... success Installed \"create-react-app@3.1.1\" with binaries: - create-react-app [############################################################################################] 92/92 Creating a new React app in H:\\React\\demo. Installing packages. This might take a couple of minutes. Installing react, react-dom, and react-scripts... yarn add v1.17.3 info No lockfile found. [1/4] Resolving packages... [2/4] Fetching packages... error eslint@6.2.2: The engine \"node\" is incompatible with this module. Expected version \"^8.10.0 || ^10.13.0 || &gt;=11.10.1\". Got \"10.8.0\" error Found incompatible module. info Visit https://yarnpkg.com/en/docs/cli/add for documentation about this command. Aborting installation. yarnpkg add --exact react react-dom react-scripts --cwd H:\\React\\antd-demo has failed. Deleting generated file... package.json Deleting antd-demo/ from H:\\React Done. error Command failed. Exit code: 1 Command: C:\\Users\\YWL\\AppData\\Local\\Yarn\\bin\\create-react-app Arguments: antd-demo Directory: H:\\React Output: info Visit https://yarnpkg.com/en/docs/cli/create for documentation about this command. PS H:\\React&gt; yarn start yarn run v1.17.3 error Couldn't find a package.json file in \"H:\\\\React\" info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command. 解决 yarn config set ignore-engines true","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"}],"tags":[{"name":"React","slug":"React","permalink":"https://wangchuaichuai.github.io/tags/React/"}],"author":"王小欣"},{"title":"react报错 Can't perform a React state update on an unmounted component","slug":"react报错：Can't perform a React state update on an unmounted component1","date":"2022-05-02T08:37:00.000Z","updated":"2022-05-27T02:23:13.732Z","comments":true,"path":"posts/3b89b733.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/3b89b733.html","excerpt":"","text":"react报错：Can’t perform a React state update on an unmounted component在React开发中，我们经常可能会遇到这样一个警告： ERROR: Can't perform a React state update on an unmounted component This is a no-op, but it indicates a memory leak in your application. 我们不能在组件销毁后设置state，防止内存泄漏关于react中切换路由时报以上错误，实际的原因是因为在组件挂载（mounted）之后进行了异步操作，比如ajax请求或者设置了定时器等，而你在callback中进行了setState操作。当你切换路由时，组件已经被卸载（unmounted）了，此时异步操作中callback还在执行，因此setState没有得到值。 解决的方式有两种： 一、在卸载的时候对所有的操作进行清除（例如：清除定时器） componentDidMount = () =&gt; { timer = setTimeout( () =&gt; { }, 1000) } componentWillUnMount = () =&gt; { clearTimeout(timer) } // hooks中使用useeffect模拟生命周期 二、设置一个flag，当unmount的时候重置这个flag componentDidMount =() =&gt; { this.flag = true axios操作 } componentWillUnMount =() =&gt; { this.flag = false } // hooks中使用useeffect模拟生命周期 三、最简单的方式（万金油） componentDidMount =() =&gt; { axios请求 } componentWillUnmount =() =&gt; { this.setState = (state, callback) =&gt; { return; } }","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"}],"tags":[{"name":"React","slug":"React","permalink":"https://wangchuaichuai.github.io/tags/React/"}],"author":"王小欣"},{"title":"typescript使用可选属性报错可能未定义","slug":"typescript使用可选属性报错可能未定义","date":"2022-05-01T03:37:00.000Z","updated":"2022-05-02T14:31:07.935Z","comments":true,"path":"posts/57632486.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/57632486.html","excerpt":"","text":"typescript使用可选属性报错可能未定义当使用可选属性的时候，可能会报参数未定义的错误 interface Info{ user:string name:?string password:?string } export const UserInfo = ( state = defaultState, action: Info) =&gt; { switch(action.type){ case:1 {return ...state} case:2 {return ...state} default:{return ...state} } } 解决：将tsconfig.json中的strict属性设置为false，取消严格模式即可 \"compilerOptions\": { \"strict\": false }","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://wangchuaichuai.github.io/tags/typescript/"}],"author":"王小欣"},{"title":"前端进行下载图片","slug":"前端下载图片","date":"2022-03-21T13:37:00.000Z","updated":"2022-03-22T09:55:33.110Z","comments":true,"path":"posts/b3977ed7.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/b3977ed7.html","excerpt":"","text":"前端进行下载图片 同源情况 // 这种情况下必须是同源，否则download则会失效 &lt;a href=\"你的图片的地址\" download=\"名字\"&gt;下载图片&lt;/a&gt; 非同源情况 原理类似，不过利用canvas来进行画图 function getIt(name: string,src: string) { let src = src let canvas = document.createElement('canvas') let image = document.createElement('img') image.setAttribute('crossOrigin', 'anonymous') image.onload = function (e) { canvas.width = image.width canvas.height = image.height let context = canvas.getContext('2d') context.drawImage(image, 0, 0, image.width, image.height) canvas.getContext('2d').drawImage(image, 0, 0, image.width, image.height) // const url = canvas.toDataURL('image/png') canvas.toBlob((blob) =&gt; { let link = document.createElement('a') link.href = window.URL.createObjectURL(blob) link.download = 'fileName' link.click() }) } image.src = src }","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"}],"tags":[{"name":"React","slug":"React","permalink":"https://wangchuaichuai.github.io/tags/React/"}],"author":"王小欣"},{"title":"React useNavigate 和 useLocation的使用","slug":"useLocation-useNavigate","date":"2022-03-18T03:37:00.000Z","updated":"2022-03-22T09:55:33.107Z","comments":true,"path":"posts/e78137ec.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/e78137ec.html","excerpt":"","text":"React useNavigate 和 useLocation的使用使用useNavigate来跳转，在页面内使用useLocation来接收数据 // 发送 import { useNavigate } from 'react-router-dom' let navigate = useNavigate() function post() { let name = 'hello' let psw = 123123 navigate( 'name', { state: { name: name, psw: psw } } ) } // 接收 import { useLocation } from 'react-router-dom' let localtion = useNavigate() const { state1 } = localtion const state2 = localtion.state // 均能获取数据","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"}],"tags":[{"name":"React","slug":"React","permalink":"https://wangchuaichuai.github.io/tags/React/"}],"author":"王小欣"},{"title":"useSelector与useDispatch","slug":"useSelector-useDispatch","date":"2022-03-17T03:37:00.000Z","updated":"2022-03-22T09:55:33.108Z","comments":true,"path":"posts/65b0b16f.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/65b0b16f.html","excerpt":"","text":"useSelector与useDispatch在hooks中替代connect来连接react和redux的方式是用useDispatch和useSelector，就无需使用connect的一堆模式化的语法了useSelector和mapStateToProps效果类型，是用来get数据的，但是使用起来异常简介有两个参数，第一个传入一个函数，返回一个对象，对象里面可以获取到store中的数据，第二个值是对性能优化的，传入的值来判断true or false来决定是否重新渲染，类似React.memo的第二个参数，进行一次浅比较 useDispatch则是用来dispatch一个action的，如上图创建后直接在括号中写入要dispatch的action即可 let dispatch = useDispatch() dispatch(action.login(name:string,psw:string)) 这样即可dispatch成功","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"}],"tags":[{"name":"React","slug":"React","permalink":"https://wangchuaichuai.github.io/tags/React/"}],"author":"王小欣"},{"title":"React报错 TypeError Cannot call a class as a function","slug":"redux-thunk无法引入","date":"2022-03-14T03:37:00.000Z","updated":"2022-05-27T02:34:53.208Z","comments":true,"path":"posts/f450a672.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/f450a672.html","excerpt":"","text":"React报错：TypeError: Cannot call a class as a function极其极其不小心的错误，redux-thunk异步组件的引入是引入redux-thunk而不是引入react-thunk，否则代码不会报错反而代码写完后运行报错","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"}],"tags":[{"name":"React","slug":"React","permalink":"https://wangchuaichuai.github.io/tags/React/"}],"author":"王小欣"},{"title":"Echarts不显示","slug":"ECharts不显示","date":"2022-03-13T03:37:00.000Z","updated":"2022-03-22T09:55:33.101Z","comments":true,"path":"posts/676031c.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/676031c.html","excerpt":"","text":"Echarts不显示在完成加入echarts后的网页中虽然能查看到元素节点，但是并没有显示出来，原因是因为没有给标签高度，可以给标签高度或者给创建的ECharts元素加size属性 let myChart = echarts.init('main') myChart.resize({ height:'100px' }) 这样就能正常显示了","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"}],"tags":[{"name":"React","slug":"React","permalink":"https://wangchuaichuai.github.io/tags/React/"}],"author":"王小欣"},{"title":"Echarts Initialize failed invalid dom 根本解决","slug":"Echarts报错Initialize failed invalid dom","date":"2022-03-13T03:37:00.000Z","updated":"2022-03-22T09:55:33.105Z","comments":true,"path":"posts/651e55e3.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/651e55e3.html","excerpt":"","text":"Echarts在渲染时出错Uncaught Error: Initialize failed: invalid dom其原因是因为dom还没有渲染完就开始ECharts的初始化（init）操作 解决react：可以将其放在useEffect函数中，在结构全部渲染完毕之后再进行ECharts的渲染操作 vue：使用ref来解决，使用this.$ref来获取对应的标签而不是用getELementById","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"}],"tags":[{"name":"React","slug":"React","permalink":"https://wangchuaichuai.github.io/tags/React/"}],"author":"王小欣"},{"title":"process.env.NODE_ENV === 'production' 总是为false或无法使用该命令","slug":"process.env.NODE_ENV === 'production' 总是为false","date":"2022-03-09T16:00:00.000Z","updated":"2022-03-14T12:40:03.291Z","comments":true,"path":"posts/8f8d86be.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/8f8d86be.html","excerpt":"","text":"vue当文字很多的时候使用…代替原本的配置是 // linux或者mac \"serve\":\"NODE_ENV=production node app.js\" // windows \"serve\":\"SET NODE_ENV=production &amp;&amp; node app.js\" 而console.log一下命令发现始终为false，无法转为生产环境而在打印出的情况下发现production的签名是有一个空格的，问题根本发现，是在命令中输入空格的时候不会自动省略而是也把他加入到了执行的命令中，而他又判断production和空格+production不一致所以始终为false所以 \"serve\":\"SET NODE_ENV=production&amp;&amp; node app.js\" 还要注意一点在windows下使用scripty来管理命令的时候是.bat后缀而不是linux下的.sh后缀","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"},{"name":"JS","slug":"JS","permalink":"https://wangchuaichuai.github.io/tags/JS/"}],"author":"王小欣"},{"title":"样式中隐藏滚动条","slug":"样式中隐藏滚动条","date":"2022-03-08T06:24:00.000Z","updated":"2022-03-14T12:48:46.294Z","comments":true,"path":"posts/22f4609d.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/22f4609d.html","excerpt":"","text":"样式中隐藏滚动条项目中有一个长页面，而内部内容多则会撑开组件的长度，此时会出现滚动条，而有时候这个滚动条会特别难看，需要有一个隐藏滚动条的操作。 // 适用于chrom内核与safari环境下 .box::-webkit-scrollbar { display:none; } // 适用于IE10或以上 .box{ -ms-overflow-style:none; } // 适用于firefox .box{ overflow:-moz-scrollbars-none; } 如果不是这些环境的话，只需要设置其滚动条所在的高度比你容器的高度大即可，这样就能把滚动条所在的位置挤出去完成界面上的’隐藏滚动条’","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"},{"name":"axios","slug":"axios","permalink":"https://wangchuaichuai.github.io/tags/axios/"}],"author":"王小欣"},{"title":"Can't perform a React state update on an unmounted component. This is a no-","slug":"定时器引发的问题","date":"2022-03-05T06:24:00.000Z","updated":"2022-03-14T12:48:46.293Z","comments":true,"path":"posts/da69ad47.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/da69ad47.html","excerpt":"","text":"Warning: Can’t perform a React state update on an unmounted component. This is a no-react报错其根本是原因是在组件销毁后异步操作还没有完成，但是组件又销毁了而出现的问题。解决方法：最简单的就是将其放置在WillUnmount中防止销毁后依旧调用 componentDidMount = () =&gt; { axios操作 .then( res =&gt; { this.setState({ 设置值 }) }) } componentWillUnmount(){ this.setState = (state, callback) =&gt; { return ; } } 即可解决报错","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"react","slug":"react","permalink":"https://wangchuaichuai.github.io/tags/react/"}],"author":"王小欣"},{"title":"forEach和for的return","slug":"forEach的return","date":"2022-03-02T02:04:00.000Z","updated":"2022-03-02T02:04:45.304Z","comments":true,"path":"posts/dea3fb4f.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/dea3fb4f.html","excerpt":"","text":"记一次小结在forEach循环中使用return会跳出本次循环然后进行下一次在for中使用return会直接结束循环 let arr = ['1', '2', '3'] arr.forEach( item =&gt; { console.log('forEach', item) return item }) 1, 2, 3, for( let i = 0; i &lt; arr.length; i++){ console.log('for', arr[i]) return arr[i] } 1,","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wangchuaichuai.github.io/tags/JavaScript/"}],"author":"王小欣"},{"title":"JS与QA","slug":"js与QA工程师","date":"2022-01-28T12:54:00.000Z","updated":"2022-01-29T14:08:02.791Z","comments":true,"path":"posts/bb4fa3e3.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/bb4fa3e3.html","excerpt":"","text":"函数式编程与单元测试性能测试：autocannon、wrk、jarvis接口测试：Mocha、Mock Service Worker、SuperTest、AVA单元测试：Enzyme、react-testing-library、Istanbul断言库：Jasmine、Chai综合测试：Karma、Jest、Polly.js(拦截、重放)、storybook、F2eTest、sinonjs（storybook+jest 比较好)E2E测试：Cypress、jsdom、Browsersync、selenium-webdriver、pupeteer、NightWatch、WebdriverIP模拟测试：json-server、nock(http转发)UI测试：BacktopJS 单元测试框架better-assert(TDD断言库)should.js(BDD断言库)expect.js(BDD断言库)chai.js(TDD BDD 双模)Jasmine.js(BDD)Node.js本身集成 require(“assert”)Intern 单元测试框架QUnit jQuery得测试框架Macaca 完整得自动化测试解决方案 from阿里巴巴 单元测试运行流程 before ==&gt; beforeEach ==&gt; it ==&gt; after =&gt; afterEach 1.before单个测试用力(it)开始前 2.beforeEach每一个测试用例开始前 3.it定义测试用例，并利用断言库进行设置chai如:expect(x).to.equal(true)； 异步mocha 4.利用mock karma自动化单元测试karma 自动化runner集成PhantomJS无刷新(yarn add karma -D启动器yarn add karma-jasmine karama-chrome-launcher jasmine-core -D)npm install -g karmanpm install karma-cli -Dnpm install karma-chrome-launcher -Dnpm install karma-phantomjs-launcher -Dnpm install karma-mocha -Dnpm install karma-chai -D 流程创建项目后创建tests文件夹存放测试后缀为xxx.spec.js通用语法 describe('测试XXX函数',function ( ) { it(\"XXX函数中得某一个应用\",function ( ) { //断言库得使用稍有区别 expect(window.add(1).toBe(2)); }) }) karma.conf.js文件中得files中添加测试文件和被测试文件eg: files:[ './test/**/*.js', //ps:/**/*.js是递归查找得意思,windows不支持 './test/**/*.spec.js' ] 安装好karma后需要在package.json中配置karma在scripts中添加配置 \"karma:init\": \"karma init\" 运行yarn karma:init来添加需要得配置，具体看karma官网 \"karma:start\": \"karma start\"","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://wangchuaichuai.github.io/tags/JS/"},{"name":"QA","slug":"QA","permalink":"https://wangchuaichuai.github.io/tags/QA/"}],"author":"王小欣"},{"title":"JS问题总结","slug":"js问题总结","date":"2022-01-25T12:54:00.000Z","updated":"2022-01-29T14:08:02.788Z","comments":true,"path":"posts/bf3cf5fa.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/bf3cf5fa.html","excerpt":"","text":"toPrimitive需要先在valueOF中找返回值，再在toString中找 let obj = { valueOf: function () { return {} }, toString: function () { return {} } } 装箱：把基本的数据类型转化为对应的引用类型拆箱：把引用类型的数据转化为对应的基本类型 var s1 = '哈哈'; // new String('哈哈')，进行了一层装箱，使s1可以使用字符串的方法 console.log([] + {}) {} + [] {}代表一个代码块，则{} + []代表 + [] 则为0 {}不能直接使用，因为会被识别成代码块，需要将用()包裹 ({}).valueOf().toString() 为 '[object Object]' object为标识符，Object为类型 在ts中只能用object而不能用Object因为范围太宽泛了 [] + {} [].valueOf() 为 [] [].valueoF().toString() 为 \"\"空字符串 则[] + {} 为 \"\" + {} 为 '[object Object]' [] == false 为true，[]换后为''空字符串，但是js中' '不管里面有多少空格也是false 在比较的时候需要拆箱，在用if等条件的时候为true if ([]){ console.log('xxx') } 拼接 ('b' + 'a' + +'a' + 'a').toLocaleLowerCase() 结果为'banana' 拆解为 b + a + (+a) + a，中间是加上一个+'a'，结果为NAN，NAN是一个非常特殊的数字 0 == “0” 为true 虽然不是一种数据类型但是需要拆箱 \"0\".valueOf().toString() 为 \"0\" 0..valueOf().toString() 为\"0\" 0不能直接拆箱需要.来转为对象再调用方法 装箱的时候则不行 Boolean(\"0\") == Boolean(0) 结果为false 0在任何里面的Boolean都为false NAN == 0 false NAN == NAN false null == null true null &lt;= 0 为true null &gt;= 0 为true 但是 null &lt; 0 为false || null &gt; 0 为false 1+{} ==&gt; 1[object Object] console.log(1+null) ==&gt; 1 1+NAN ==&gt; NAN 1. var obj = {}; var x = +obj.one?.name ?? '哈哈' console.log(x) //NaN 2. var obj = {}; var x = ~obj.one?.name ?? '哈哈' console.log(x) //-1 + - 转为NAN ~转为 -1,都是运算符 ?? 代表前面是否是null或者undefined，是则为后面 var a = '哈哈' console.log(typeof a) // String console.log(a instanceof String) //false a的类型是一个string但是是装箱后的，本身只是一个自变量无任何意义，只有在使用的时候才去装箱成为对应的类型 3个可能造成闭包的东西 1. eval 2. with(vue底层大量使用) 在with绑定的东西若在变量中找不到则会将其注册在全局中 var obj = {} with(obj) { a = '哈哈' } obj.a ==&gt; undefined a ==&gt; '哈哈' 3. new Function new Function(console.log(a)) new Function('console.log(a)') 加引号会在全局中访问a","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://wangchuaichuai.github.io/tags/JS/"}],"author":"王小欣"},{"title":"算法初步学习","slug":"算法 - 副本","date":"2022-01-24T12:54:00.000Z","updated":"2022-01-29T14:08:02.794Z","comments":true,"path":"posts/81ca12be.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/81ca12be.html","excerpt":"","text":"算法的五大特征 有穷性：算法必须能在执行有限个步骤之后终止 确切性：每一步骤必须有确切的定义 输入项：有0个或者多个输入，来规定初始情况，0个指的是算法本事定出了初始条件 输出项：有一个或者多个输出，是对输入数据处理后的结果，没有输出的算法毫无意义 可行性：算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步，每个计算步都可以在有限时间内完成(也被称为有效性) 衡量好坏 复杂度：时间(拆分为基本步骤而不是看执行次数)、空间复杂度 正确性：不能有隐含bug 可读性：能不能很好的维护 健壮性(鲁棒性) 必须掌握的基本算法枚举算法核心：枚举所有可能本知：从所有候选答案中去搜索正确的解，使用该算法需要满足两个条件 可预先确定候选答案的数量 候选答案的范围在求解之前必须有一个确定的集合 特点：枚举算法简单粗暴，暴力的枚举所有可能，尽可能地尝试所有地方法速度慢实现最简单，并且得到地结果总是正确地 递归算法核心：通过重复将问题分解为同类地子问题特点： 函数可以通过调用自身来进行递归 递归可以完全取代循环 递归由两部分组成：递归主体，就是要循环解决地问题地代码递归跳出地条件，否则回一直递归爆栈 排序稳定性是一组数据排序后可能出现结果不一样例如a,b数据一样但是排序后a可能在b前也可能在b后排序法 最佳时间复杂度 平均时间复杂度 最差时间复杂度 空间复杂度 稳定性冒泡 n n² n² 1 yes插入 n n² n² 1 yes选择 n² n² n² 1 no二叉树 nlogn nlogn nlogn 1 yes快速 n logn nlogn n² logn~n no堆排序 nlogn nlgon nlogn 1 no希尔 nlogn nlgon n² 1 no 查找查找算法 平均时间复杂度 查找条件顺序查找 n 无需或有序队列二分(折半查找) nlogn 有序数组二叉排序树查找 nlogn 二叉排序树哈希表法(散列表) 1 先创建哈希表(散列表)分块查找 nlogn 无序或有序队列","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wangchuaichuai.github.io/tags/%E7%AE%97%E6%B3%95/"}],"author":"王小欣"},{"title":"设置localstorage过期时间","slug":"localstorage过期事件","date":"2022-01-22T12:54:00.000Z","updated":"2022-01-29T14:08:02.791Z","comments":true,"path":"posts/115e4fbf.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/115e4fbf.html","excerpt":"","text":"设置localstorage过期时间由于localstorage一旦存入除非手动清除则无法删除内容，而我们又需要定期调用来保证数据的更新，所以需要存入一个时间 过程：在存入localstorage的时候同时存入当下的事件 var storage = window.localStorage var currTime = new Date().getTime() storage.setItem('res', JSON.stringify({ res1: res1, res2: res2, res3: res3, res4: res4, res5: res5, time: currTime })) 此时从localstorage的res中即可读取到存入的对应信息以及time在读取的时候new一个时间，与存入的时间进行对比，若超出存放时间则手动清空localstorage的内容 var res = JSON.parse(storage.getItem('res')) // 时间多余500s则重新请求 if (new Date().getTime() - res.time &gt; 6500000) { console.log(new Date().getTime) console.log(res.currTime) storage.removeItem('res') } } else { console.log('本地化未存储') this.getIndex() }","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"},{"name":"axios","slug":"axios","permalink":"https://wangchuaichuai.github.io/tags/axios/"}],"author":"王小欣"},{"title":"CSS伪类/元素","slug":"css伪元素","date":"2022-01-20T12:54:00.000Z","updated":"2022-01-29T14:08:02.787Z","comments":true,"path":"posts/216ce903.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/216ce903.html","excerpt":"","text":"CSS 伪类(Pseudo-classes)CSS伪类是用来添加一些选择器的特殊效果语法selector:pseudo-class {property:value;}css的类也可以使用伪类selector.class:pseudo-class {property:value;}可以通过选择对应的类来更改后端传回的带有html标签的样式 所有的选择器选择器 示例 示例说明:checked input:checked 选择所有选中的表单元素:disabled input:disabled 选择所有禁用的表单元素:empty p:empty 选择所有没有子元素的p元素:enabled input:enabled 选择所有启用的表单元素:first-of-type p:first-of-type 选择的每个 p 元素是其父元素的第一个 p 元素:in-range input:in-range 选择元素指定范围内的值:invalid input:invalid 选择所有无效的元素:last-child p:last-child 选择所有p元素的最后一个子元素:last-of-type p:last-of-type 选择每个p元素是其母元素的最后一个p元素:not(selector) :not(p) 选择所有p以外的元素:nth-child(n) p:nth-child(2) 选择所有 p 元素的父元素的第二个子元素:nth-last-child(n) p:nth-last-child(2) 选择所有p元素倒数的第二个子元素:nth-last-of-type(n) p:nth-last-of-type(2) 选择所有p元素倒数的第二个为p的子元素:nth-of-type(n) p:nth-of-type(2) 选择所有p元素第二个为p的子元素:only-of-type p:only-of-type 选择所有仅有一个子元素为p的元素:only-child p:only-child 选择所有仅有一个子元素的p元素:optional input:optional 选择没有”required”的元素属性:out-of-range input:out-of-range 选择指定范围以外的值的元素属性:read-only input:read-only 选择只读属性的元素属性:read-write input:read-write 选择没有只读属性的元素属性:required input:required 选择有”required”属性指定的元素属性:root root 选择文档的根元素:target #news:target 选择当前活动#news元素(点击URL包含锚的名字):valid input:valid 选择所有有效值的属性:link a:link 选择所有未访问链接:visited a:visited 选择所有访问过的链接:active a:active 选择正在活动链接:hover a:hover 把鼠标放在链接上的状态:focus input:focus 选择元素输入后具有焦点:first-letter p:first-letter 选择每个 元素的第一个字母:first-line p:first-line 选择每个 元素的第一行:first-child p:first-child 选择器匹配属于任意元素的第一个子元素的 元素:before p:before 在每个元素之前插入内容:after p:after 在每个元素之后插入内容:lang(language) p:lang(it) 为元素的lang属性选择一个开始值","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"},{"name":"axios","slug":"axios","permalink":"https://wangchuaichuai.github.io/tags/axios/"}],"author":"王小欣"},{"title":"vue中的跨域问题，axios和vue.config.js的devServer.proxy","slug":"vue跨域","date":"2022-01-18T12:54:00.000Z","updated":"2022-01-29T14:08:02.793Z","comments":true,"path":"posts/3017c2cf.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/3017c2cf.html","excerpt":"","text":"vue中的跨域问题，axios和vue.config.js的devServer.proxy在开发/测试环境中，因为下面会使用proxy方法，所以此处的baseURL不太重要，它在proxy中会被替换，随便写也没事 // 创建 axios 实例 开发域名 const wristbandService = axios.create({ baseURL: '', //设置为空 // baseURL: 'xxx', //设置baseURL相当于给所有此类请求前加上baseURL，这里可以用导入的变量 timeout: 6000, headers: { 'Content-Type': 'application/json; charset=utf-8' } }) vue.config.js中devServer配置注意：devServer用于本地开发环境，生产环境是不生效的。https://cli.vuejs.org/zh/config/#devserver-proxy 在下面的代码里： 1、proxy会拦截所有url中可以成功匹配到 ‘/api/wristband’ 的请求。（proxy采用正则匹配，一旦url中包含你要的字符串则停止向下匹配，详查proxy匹配规则） 2、它会把拦截到的请求中的baseUrl替换为此处的target 3、changeOrigin：true 表示跨域 module.exports = { // pabulicPath:process.env.NODE_ENV === 'production' ? '' : '', devServer: { host: '0.0.0.0', port: '8080', // https:false, open: true, proxy: { //配置跨域 '/': { target: 'xxx', ws: true, changeOrigin: true, pathRewrite: { '^/': '', }, }, }, }, } api调用 import service from './request' export default { //搜索检索 getSearch(text) { return service.get(`/tstd/search/?kw=${text}`) }, } 重点api发出请求时，会将此处的url前面加上配置过的baseURL，这一个整体，会被proxy检测拦截，proxy操作过后就可以跨域了 生产(线上)环境的跨域问题：后端Nginx反向代理/cors跨域配置由于devServer只用于本地环境，生产环境是不生效的，所以上面所说的devServer.proxy方法无效","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"},{"name":"axios","slug":"axios","permalink":"https://wangchuaichuai.github.io/tags/axios/"}],"author":"王小欣"},{"title":"JS中的NAN","slug":"NAN","date":"2022-01-16T12:54:00.000Z","updated":"2022-01-29T14:08:02.786Z","comments":true,"path":"posts/b938e569.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/b938e569.html","excerpt":"","text":"JS中的NANJavaScript中，NaN是一个特殊的数字值（typeof NaN的结果为number），是not a number的缩写，表示不是一个合法的数字。 NAN的产生： 一个无法被解析的数字 //一个无法被解析的数字 Number('abc') //NAN Number(undefined) //NAN //与数字有关的失败的操作 Math.log(-1) //NAN Math.sqrt(-1) //NAN //运算符 NAN + 1 //NAN 注意NAN是唯一一个与自身不相等的值 console.log(NAN === NAN) //NAN 辨别NAN 使用函数isNaN()来判断一个数值是不是一个非数字isNaN(NaN)但是无法去辨别字符isNaN(‘a’) //true 参考：《深入理解javascript》","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"},{"name":"JS","slug":"JS","permalink":"https://wangchuaichuai.github.io/tags/JS/"}],"author":"王小欣"},{"title":"vue2.x错误 - Do not use built-in or reserved HTML elements as component id header","slug":"vue2.X报错","date":"2022-01-15T12:54:00.000Z","updated":"2022-05-27T02:27:20.567Z","comments":true,"path":"posts/5fdefbba.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/5fdefbba.html","excerpt":"","text":"vue2.x错误 - Do not use built-in or reserved HTML elements as component id: header原因：vue组件名称(属性)于HTML5标签名称冲突，注意vue组件命名不要与已有标签一直即可。","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"},{"name":"配置篇","slug":"学习篇/配置篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/%E9%85%8D%E7%BD%AE%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"}],"author":"王小欣"},{"title":"ES6——``","slug":"ES6--``","date":"2022-01-13T12:54:00.000Z","updated":"2022-01-29T13:31:50.049Z","comments":true,"path":"posts/619c24be.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/619c24be.html","excerpt":"","text":"ES6中的``es6中允许使用 ``创建字符串模板,可以直接写回车空格编写html或文本 var a = `&lt;div&gt;123&lt;/div&gt;` 在字符串拼接中可以代替’’以及””，直接拼接 ```javascriptlet a = ‘小王’console.log(我是${a})","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"},{"name":"配置篇","slug":"学习篇/配置篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/%E9%85%8D%E7%BD%AE%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"}],"author":"王小欣"},{"title":"input值变化，延时触发事件(防抖，节流)","slug":"input值变化延时防抖","date":"2022-01-12T12:54:00.000Z","updated":"2022-01-29T13:31:50.054Z","comments":true,"path":"posts/eb5c39a4.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/eb5c39a4.html","excerpt":"","text":"input值变化，延时触发事件(防抖，节流) debounce防抖 function debounce(method,delay){ var timer = null; return function(){ var context = this,args = arguments; clearTimeout(timer); timer = setTimeout(function(){ method.apply(context,args); },delay); } } // 防抖函数 const debounce = (fn, delay) =&gt; { let timer = null; return (...args) =&gt; { clearTimeout(timer); timer = setTimeout(() =&gt; { fn.apply(this, args); }, delay); }; }; throttle节流 function throttle(method, delay, time) { var timeout,startTime = +new Date(); return function() { var context = this, args = arguments, curTime = +new Date(); clearTimeout(timeout); // 如果达到了规定的触发时间间隔，触发 handler if (curTime - startTime &gt;= time) { method.apply(context, args); startTime = curTime; } else { // 没达到触发间隔，重新设定定时器 timeout = setTimeout(method, delay); } }; // 节流函数 const throttle = (fn, delay = 500) =&gt; { let flag = true; return (...args) =&gt; { if (!flag) return; flag = false; setTimeout(() =&gt; { fn.apply(this, args); flag = true; }, delay); }; }; 原文地址：https://www.cnblogs.com/ImmortalWang/p/11551159.html","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"},{"name":"配置篇","slug":"学习篇/配置篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/%E9%85%8D%E7%BD%AE%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"}],"author":"王小欣"},{"title":"window.location.href的用法(动态输出跳转)","slug":"location.href","date":"2022-01-10T12:54:00.000Z","updated":"2022-01-29T13:31:50.057Z","comments":true,"path":"posts/3f877806.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/3f877806.html","excerpt":"","text":"window.location.href的用法(动态输出跳转)javascript中的location.href有很多种用法，主要如下。 self.location.href=”/url” 当前页面打开URL页面location.href=”/url” 当前页面打开URL页面windows.location.href=”/url” 当前页面打开URL页面，前面三个用法相同。this.location.href=”/url” 当前页面打开URL页面parent.location.href=”/url” 在父页面打开新页面top.location.href=”/url” 在顶层页面打开新页面 如果页面中自定义了frame，那么可将parent self top换为自定义frame的名称,效果是在frame窗口打开url地址 此外，window.location.href=window.location.href;和window.location.Reload()和都是刷新当前页面。区别在于是否有提交数据。当有提交数据时，window.location.Reload()会提示是否提交，window.location.href=window.location.href;则是向指定的url提交数据","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"}],"author":"王小欣"},{"title":"vue package.json项目名 只能设置小写 办法","slug":"package.json项目名","date":"2022-01-10T12:54:00.000Z","updated":"2022-01-29T13:31:50.058Z","comments":true,"path":"posts/d22e9114.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/d22e9114.html","excerpt":"","text":"vue package.json项目名npm显示仅仅为英文无法设置中文修改dist打包目录后的 index.html的 所需标题","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"},{"name":"配置篇","slug":"学习篇/配置篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/%E9%85%8D%E7%BD%AE%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"}],"author":"王小欣"},{"title":"Vue打开PDF文件","slug":"vue打开PDF文件","date":"2022-01-09T12:54:00.000Z","updated":"2022-01-29T13:31:50.061Z","comments":true,"path":"posts/7a7b5251.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/7a7b5251.html","excerpt":"","text":"Vue打开PDF文件最简单的方式就是新建标签页打开 window.open(url) 如果出现意外的服务器相应问题原因有： 不能在本地对.pdf进行打开，比如从地址http:localhost 打开就不可以 所请求的pdf文件的路径未设置跨域","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"}],"author":"王小欣"},{"title":"前端post请求get请求内--body和query传参的区别","slug":"前端axios的post和get的区别","date":"2022-01-08T12:54:00.000Z","updated":"2022-01-29T13:31:50.062Z","comments":true,"path":"posts/14572447.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/14572447.html","excerpt":"","text":"前端post请求get请求内–body和query传参的区别 get请求只能query传参 axios.get('/user', { params: { name:data } }).then().catch post可以传body和query两种形式的参数```vueaxios.({ method:’post’, url:’/user’, data: { name: data }})","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"},{"name":"elementUI","slug":"elementUI","permalink":"https://wangchuaichuai.github.io/tags/elementUI/"}],"author":"王小欣"},{"title":"Element-UI中表格组件的table slot用法","slug":"el-table中的slot","date":"2022-01-07T12:54:00.000Z","updated":"2022-01-29T13:31:50.051Z","comments":true,"path":"posts/2ae6ef4e.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/2ae6ef4e.html","excerpt":"","text":"Element-UI中表格组件的table slot用法&lt;el-table-column type=\"index\" :index=\"1\" label='序号' width='100'&gt; &lt;/el-table-column&gt; &lt;div slot=\"append\" style=\"text-align: center\"&gt; &lt;!--在此处添加你想要插入在表格最后一行的内容--&gt; 123 &lt;/div&gt;","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"},{"name":"elementUI","slug":"elementUI","permalink":"https://wangchuaichuai.github.io/tags/elementUI/"}],"author":"王小欣"},{"title":"element-ui 的 el-table 上使用无限滚动加载（与自带的 infinite-scroll 结合）","slug":"el-table滚动","date":"2022-01-06T12:54:00.000Z","updated":"2022-01-29T13:31:50.053Z","comments":true,"path":"posts/7c2421e7.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/7c2421e7.html","excerpt":"","text":"element-ui 的 el-table 上使用无限滚动加载（与自带的 infinite-scroll 结合）依赖于element-UI安装 npm install --save el-table-infinite-scroll 全局引入 import Vue from 'vue' import elTableInfiniteScroll from 'el-table-infinite-scroll' Vue.use(elTableInfiniteScroll) 局部引入 &lt;script&gt; import elTableInfiniteScroll from 'el-table-infinite-scroll'; export default { directives: { 'el-table-infinite-scroll': elTableInfiniteScroll } } &lt;/script&gt; 组件中使用 &lt;template&gt; &lt;el-table border height=\"400px\" v-el-table-infinite-scroll=\"load\" :data=\"tableData\" &gt; &lt;el-table-column prop=\"date\" label=\"日期\" width=\"180\"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=\"name\" label=\"姓名\" width=\"180\"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=\"address\" label=\"地址\"&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/template&gt; &lt;script&gt; import elTableInfiniteScroll from 'el-table-infinite-scroll'; const exampleData = new Array(10).fill({ date: '2016-05-02', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' }); export default { directives: { 'el-table-infinite-scroll': elTableInfiniteScroll }, data() { return { tableData: exampleData }; }, methods: { load() { this.$message.success('加载下一页'); this.tableData = this.tableData.concat(exampleData); } } }; &lt;/script&gt; &lt;style scoped&gt; .el-table { width: 100%; } &lt;/style&gt; 原文链接：https://blog.csdn.net/baidu_27769027/article/details/101924676","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"},{"name":"elementUI","slug":"elementUI","permalink":"https://wangchuaichuai.github.io/tags/elementUI/"}],"author":"王小欣"},{"title":"Duplicate keys detected '0' This may cause an update error.","slug":"两个v-for","date":"2022-01-05T12:54:00.000Z","updated":"2022-05-27T02:34:53.214Z","comments":true,"path":"posts/959dcd6.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/959dcd6.html","excerpt":"","text":"Duplicate keys detected: ‘0’. This may cause an update error.原因：一个template中有两个一样的v-for解决方法将两个中的一个的key修改一下即可解决问题","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"}],"author":"王小欣"},{"title":"解决el-image出现本地图片加载失败问题","slug":"el-image本地图片","date":"2022-01-04T12:54:00.000Z","updated":"2022-01-29T12:59:07.303Z","comments":true,"path":"posts/5b605baa.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/5b605baa.html","excerpt":"","text":"解决el-image出现本地图片加载失败问题原因在element ui 组件上使用相对路径，webpack并不会对路径进行处理（即为根目录下的images）。解决图片地址用 require 进行拉取。例如：:src=“require(’…/assets/login/title-picture.png’)” &lt;el-image :src=\"require('路径')\" /&gt; 原文链接：https://blog.csdn.net/jinzai9976/article/details/115364626","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"}],"author":"王小欣"},{"title":"解决el-image出现网络图片加载失败问题","slug":"el-image图片网络加载失败","date":"2022-01-03T12:54:00.000Z","updated":"2022-01-29T12:59:07.300Z","comments":true,"path":"posts/185c84b9.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/185c84b9.html","excerpt":"","text":"解决el-image出现网络图片加载失败问题图片是api接口返回的网络图片，请求是异步的，在没回来之前图片是undefined，所有在回来前使用v-if，在回来后在渲染，或者使用vue自带的this.$forceUpdate()来刷新数据 &lt;el-image v-if=\"list.cover !== undefined\" :src=\"list.cover\" fit=\"fill\" lazy&gt;&lt;/el-image&gt;","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"}],"author":"王小欣"},{"title":"elementui中el-button点击后按钮颜色不变","slug":"el-button不失焦","date":"2022-01-01T12:54:00.000Z","updated":"2022-01-29T12:59:07.298Z","comments":true,"path":"posts/4394d381.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/4394d381.html","excerpt":"","text":"elementui中el-button点击后按钮颜色不变使用el-button在点击选中后颜色变为选中的颜色，但此时点击屏幕任意部分此按钮的颜色都会变回原样，只能通过动态绑定的class来改变颜色达到颜色不变的情况 &lt;el-button :class=\"this.flag === 1?'product-select':'product'\" @click=\"onShow(1)\"&gt; &lt;div class=\"msg\"&gt; 内容 &lt;/div&gt; &lt;/el-button&gt; 动态绑定后每次选中颜色即可不变，点击屏幕也不会变回原样","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"},{"name":"移动端","slug":"移动端","permalink":"https://wangchuaichuai.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"author":"王小欣"},{"title":"手机页面监听搜索按键方法","slug":"手机页面监听搜索","date":"2021-12-30T12:54:00.000Z","updated":"2022-01-29T12:59:07.310Z","comments":true,"path":"posts/412eb8be.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/412eb8be.html","excerpt":"","text":"手机页面监听搜索按键方法如果搜索框是input标签，只需要把type设置为search即可，右侧还内置一个清除按键，此时弹出的手机键盘回车键也变成了搜索或者搜索的图标 &lt;input type=\"search\" /&gt; 获取键盘搜索事件 ```javascript//获取键盘搜索事件 var keycode = e.keyCode var searchValue = $(this).val() //回车的键盘值是13 if (keycode == ‘13’) { //搜索业务逻辑 }","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"},{"name":"移动端","slug":"移动端","permalink":"https://wangchuaichuai.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"author":"王小欣"},{"title":"vue 后台传过来的是带样式的数据","slug":"后端传回样式数据","date":"2021-12-29T12:54:00.000Z","updated":"2022-01-29T12:59:07.308Z","comments":true,"path":"posts/bd1dc7b7.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/bd1dc7b7.html","excerpt":"","text":"后台传过来的是带样式的数据 对于vue来说很简单，只需要在标签内加入v-html即可 其他： var element = document.getElementById('class'); element.innerHTML = 内容 若需要修改传回的样式内容，可以使用伪选择器进行匹配选择","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"}],"author":"王小欣"},{"title":"vue 监听键盘回车事件 @keyup.enter || @keyup.enter.native","slug":"vue监听键盘回车事件","date":"2021-12-27T12:54:00.000Z","updated":"2022-01-29T12:59:07.309Z","comments":true,"path":"posts/f9141d47.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/f9141d47.html","excerpt":"","text":"vue 监听键盘回车事件 @keyup.enter || @keyup.enter.native在使用一些经过封装过后的组件的时候，需要加.native表示使用原生的keyup或其他方法，只需要在后面更上需要的别名即可 &lt;input @keyup.enter=\"search\" /&gt; &lt;el-input @keyup.native.enter=\"search\" /&gt; 全部键盘别名.enter.tab.esc.space.up.down.left.right.delete.ctrl.alt.shift.meta(windows系统下是win键，mac下是command键)alt+c则是@keyup.alt.67ctrl+click则是@click.ctrl","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"}],"author":"王小欣"},{"title":"移动端测试网页时，右边有留白","slug":"移动端测试右边留白","date":"2021-12-26T12:54:00.000Z","updated":"2022-01-29T12:59:07.312Z","comments":true,"path":"posts/8399d5da.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/8399d5da.html","excerpt":"","text":"移动端测试网页时，右边有留白可能是由于有元素宽度超出屏幕宽度解决：设置html的width:100%，再设置水平方向隐藏超出overflow-x:hidden;一般最外层标签宽度最好使用百分比来确定，否则容易出现超出白边","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"}],"author":"王小欣"},{"title":"js修改css样式","slug":"js修改css","date":"2021-12-25T12:54:00.000Z","updated":"2022-01-29T12:59:07.305Z","comments":true,"path":"posts/e37bca25.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/e37bca25.html","excerpt":"","text":"js修改css样式 直接设置style的属性，某些情况使用这个设置！important值无效如果属性有’-‘号，就写成驼峰形式，如果想保留-号，就中括号形式element.style.height = '10px'； 直接设置属性(只能用于某些属性，相关样式会自动识别)element.setAttribute('height', 100); element.setAttribute('height', '100px'); 设置style的属性element.setAttribute('style', 'height: 100px !important'); 使用setProperty 如果要设置!important，推荐用这种方法设置第三个参数 element.style.setProperty('height', '300px', 'important'); 改变class 比如JQ的更改class相关方法因JS获取不到css的伪元素，所以可以通过改变伪元素父级的class来动态更改伪元素的样式element.className = 'blue'; element.className += 'blue fb'; 设置cssText element.style.cssText = 'height: 100px !important'; element.style.cssText += 'height: 100px !important'; 创建引入新的css样式文件 function addNewStyle(newStyle) { var styleElement = document.getElementById('styles_js'); if (!styleElement) { styleElement = document.createElement('style'); styleElement.type = 'text/css'; styleElement.id = 'styles_js'; document.getElementsByTagName('head')[0].appendChild(styleElement); } styleElement.appendChild(document.createTextNode(newStyle)); } addNewStyle('.box {height: 100px !important;}'); 使用addRule、insertRule // 在原有样式操作 document.styleSheets[0].addRule('.box', 'height: 100px'); document.styleSheets[0].insertRule('.box {height: 100px}', 0); // 或者插入新样式时操作 var styleEl = document.createElement('style'), styleSheet = styleEl.sheet; styleSheet.addRule('.box', 'height: 100px'); styleSheet.insertRule('.box {height: 100px}', 0); document.head.appendChild(styleEl); 转载自作者：静默虚空原文链接：https://www.cnblogs.com/yaomumu/p/12759060.html","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"}],"author":"王小欣"},{"title":"Vue项目打包发布到服务器，以及空白页或图片不显示问题","slug":"vue打包图片不显示","date":"2021-12-24T12:54:00.000Z","updated":"2022-01-29T12:59:07.306Z","comments":true,"path":"posts/e8a8a893.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/e8a8a893.html","excerpt":"","text":"Vue项目打包发布到服务器，以及空白页或图片不显示问题Vue项目完成后，需要打包上线。打包只需要执行命令npm run build即可，但有两点需要注意的地方，否则就会出现空白页或图片不显示问题。 修改路径位置，解决空白页问题 修改位于项目目录中的config/index.js，将assetsPublicPath: ‘/‘修改为assetsPublicPath: ‘./‘ 解决背景图片不显示问题 打包后的css文件夹内app.css文件访问static/img/’图片名’，路径错误访问不到图片。 修改位于项目目录中的build文件夹/utils.js，添加上publicPath:’../../‘，或者死图片使用require导入","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"}],"author":"王小欣"},{"title":"一则“HTTP 405 Method Not Allowed”的解决办法","slug":"405","date":"2021-12-23T12:54:00.000Z","updated":"2022-01-29T12:59:07.297Z","comments":true,"path":"posts/792a2eb8.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/792a2eb8.html","excerpt":"","text":"提示“HTTP 405”错误——“Method Not Allowed”。从字面上的意思理解，很显然是提交方法的类型错误，要么是以GET方式向POST接口提交数据，要么是POST方式项GET接口提交数据，但反反复复检查了后端接口与提交方式，都是POST，完全没有问题。仔细检查前端代码，发现编写方式如下: axios({ method: 'post', url: 'xxx', data: { name: this.input1, phone: this.input2, email: this.input3, content: this.input4 } }).then(res =&gt; { console.log(res.data.msg) this.msg = res.data.msg this.open() }).catch(error =&gt; console.log('error1')) } else { this.open() } 此时会有两个编程问题 提交的参数暴露在外 默认提交的Header参数”content-type”为”application/json” 可以新增content-type的头部属性来解决 axios({ method: 'post', url: 'xxx', data: { name: this.input1, phone: this.input2, email: this.input3, content: this.input4 }, heads: { 'content-type': 'application/x-www-form-urlencoded' } }).then(res =&gt; { console.log(res.data.msg) this.msg = res.data.msg this.open() }).catch(error =&gt; console.log('error1')) } else { this.open() } 如果要解决第一个暴露问题，只需要引入$httpParamSerializer服务即可 axios({ method: 'post', url: 'xxx', data: $httpParamSerializer({ name: this.input1, phone: this.input2, email: this.input3, content: this.input4 }), heads: { 'content-type': 'application/x-www-form-urlencoded' } }).then(res =&gt; { console.log(res.data.msg) this.msg = res.data.msg this.open() }).catch(error =&gt; console.log('error1')) } else { this.open() }","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"}],"author":"王小欣"},{"title":"vue获取DOM元素并设置属性","slug":"vue获取dom元素","date":"2021-12-22T12:54:00.000Z","updated":"2022-01-29T12:59:07.307Z","comments":true,"path":"posts/c1bdb0a4.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/c1bdb0a4.html","excerpt":"","text":"vue获取DOM元素并设置属性方法1：直接给相应的元素加id，然后使用document.getElementById(‘id’);来获取，然后设置相应属性或样式方法2：使用ref，给相应的元素加ref=”name”，然后再this.$refs.name获取到该元素，并且可以直接调用子组件中定义的方法 注意： 在获取相应元素之前，必须在mounted生命周期中进行挂在，否则会获取null值 如果给子组件加id并修改自定义属性，则会直接加到子组件外层的div伤，不会改变内部 给子组件加ref，然后获取到DOM元素之后改变相应的自定义属性的值，vue会报错","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"}],"author":"王小欣"},{"title":"解决头部使用 positionfixed； 固定定位后遮住下方内容的问题","slug":"positionfixed遮挡","date":"2021-12-21T12:54:00.000Z","updated":"2022-05-27T02:31:52.461Z","comments":true,"path":"posts/1fec658d.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/1fec658d.html","excerpt":"","text":"今天在做一个页面的时候，有一个效果是要让头部固定，但是在给了position:fixed; 后，继续往下写会发现下方内容有部分被头部遮住了，有两个办法可以解决这种问题 在头部下方给一个空的div，高度为设置position:fixed的标签的高度 把整个要使用postion:fixed的盒子用另一个盒子包起来&lt;div class=\"bottom\"&gt; &lt;h1&gt;123&lt;/h1&gt; &lt;/div&gt; &lt;style&gt; .bottom{ width:100%; height:20px; position:fixed; bottom:0; } &lt;/style&gt; 这样就设置了一个永远在底部的div，但是会发现页面拉到底部后会遮挡一部分内容，只需要在设置一个等高的盒子包裹起来就可以了&lt;div class=\"box\"&gt; &lt;div class=\"bottom\"&gt; &lt;h1&gt;123&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;style&gt; .bottom{ width:100%; height:20px; position:fixed; bottom:0; } .box{ height:20px; } &lt;/style&gt;","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"}],"author":"王小欣"},{"title":"vue中computed计算属性传入参数","slug":"computed传参","date":"2021-12-20T12:54:00.000Z","updated":"2022-01-29T12:59:07.301Z","comments":true,"path":"posts/5c8dfd6e.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/5c8dfd6e.html","excerpt":"","text":"vue中computed计算属性传入参数&lt;template&gt; &lt;div :age=\"getAge(10)\"&gt;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; computed:{ getAge(){ return age =&gt; { console.log(age) return age } } } &lt;/script&gt;","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"}],"author":"王小欣"},{"title":"如何隐藏overflow scroll的滚动条，但是滚动功能还在(保留滚动功能)","slug":"setting innerHtml","date":"2021-12-19T12:54:00.000Z","updated":"2022-05-27T02:34:53.212Z","comments":true,"path":"posts/d954a198.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/d954a198.html","excerpt":"","text":"如何隐藏overflow: scroll的滚动条，但是滚动功能还在(保留滚动功能) 适用于chrome ::-webkit-scrollbar { display: none; } 为了兼容其他浏览器，可以在滚动区域外再嵌套一层div，给div设置overflow:hidden，即可隐藏滚动条.scroll{ overflow:hidden; .scrollChild{ overflow:scroll; } } 以上方法若是还不能解决，就手动给标签层设置一个padding-bottom，把滚动条挤出可视范围.scrollChild{ overflow:scroll; overflow-y:hidden; padding-bottom:10px; }","categories":[{"name":"配置篇","slug":"配置篇","permalink":"https://wangchuaichuai.github.io/categories/%E9%85%8D%E7%BD%AE%E7%AF%87/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wangchuaichuai.github.io/tags/css/"},{"name":"html","slug":"html","permalink":"https://wangchuaichuai.github.io/tags/html/"}],"author":"王小欣"},{"title":"PWA","slug":"PWA","date":"2021-12-15T12:54:00.000Z","updated":"2021-12-24T04:13:41.929Z","comments":true,"path":"posts/67dc4d37.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/67dc4d37.html","excerpt":"","text":"PWA全称是Progressive Web App PWA组成 Service Worker Promise fetch cache API Notification API Service Worker(最重要)服务工作线程 常驻内存运行 代理网络请求 依赖HTTPS需要先进行service worker的注册navigator.serviceWorker.register(‘./sw.js’,{ scope: ‘/‘}).then(registration =&gt; { console.log(registration)}, error =&gt; { console.error(error)})在sw.js中进行service worker的操作 Promise承诺 控制流 优雅的解决并优化回调地狱问题 async/await语法同步化 service wroker 的API风格 fetch网络请求 比XMLHttpRequest更简介 Promise的风格特点 依旧存在不足 cache API支持资源的缓存系统 缓存资源(css/scripts/image) 依赖Service Worker 代理网络请求 支持离线程序运行 Notification API消息推送 依赖用户授权 适合在Service Worker中推送","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"}],"tags":[{"name":"PWA","slug":"PWA","permalink":"https://wangchuaichuai.github.io/tags/PWA/"}],"author":"王小欣"},{"title":"已拦截跨源请求：同源策略禁止读取位于 'http//请求地址schoolUser/getTelecomNetWorkNumber' 的远程资源","slug":"跨域拦截","date":"2021-12-13T04:37:00.000Z","updated":"2022-05-27T02:30:53.418Z","comments":true,"path":"posts/2f4a60c0.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/2f4a60c0.html","excerpt":"","text":"已拦截跨源请求：同源策略禁止读取位于 http://请求地址schoolUser/getTelecomNetWorkNumber 的远程资源已拦截跨源请求：同源策略禁止读取位于 http://请求地址:8081/schoolUser/getTelecomNetWorkNumber 的远程资源。如何解决。这种跨源请求禁止读取的原因是：CORS 头缺少 ‘Access-Control-Allow-Origin’，所以在要请求的接口上加上 //解决跨域请求问题 response.setHeader(\"Access-Control-Allow-Origin\",\"*\"); 问题解决","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"学习篇","slug":"技术篇/学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"跨域","slug":"跨域","permalink":"https://wangchuaichuai.github.io/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"http","slug":"http","permalink":"https://wangchuaichuai.github.io/tags/http/"}],"author":"王小欣"},{"title":"vant完成下拉选择","slug":"vant完成下拉选择","date":"2021-12-12T04:00:00.000Z","updated":"2021-12-21T09:09:29.699Z","comments":true,"path":"posts/43fee1dd.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/43fee1dd.html","excerpt":"","text":"使用vant完成一个下拉选择按钮完成筛选的组件完成效果思路比较简单，先使用vant组件中的下拉，再搭配cell完成每一块的构建 通过动态判断点击哪一个按钮来绑定被点击的按钮的样式，这样就能简单的知道点击了哪一个按钮 再通过一组绑定同一个数据value1，这样便能达到选择一个的目的，通过selectOne方法来选择传入的值来动态改变value绑定的值再搭配switch来选择每一个值的方法，例如我在上面费用情况，也就是第一组按钮中分别给不限、免费、收费绑定了0，1，2的值，在通过switch case来看选择了哪个值，然后来筛选对应的内容 这样就完成了一个简易的下拉筛选框，虽然比较简陋，可能性能也不是很好，但也是完成了内容了~","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"学习篇","slug":"技术篇/学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"},{"name":"vant","slug":"vant","permalink":"https://wangchuaichuai.github.io/tags/vant/"}],"author":"王小欣"},{"title":"vue父组件监听子组件的生命周期","slug":"vue父组件监听子组件的生命周期","date":"2021-12-11T04:12:00.000Z","updated":"2021-12-21T09:09:25.230Z","comments":true,"path":"posts/8217f149.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/8217f149.html","excerpt":"","text":"vue父组件监听子组件的生命周期 通过$emit实现 以mounted为例，在父组件Parent和子组件Child中，如果父组件监听到子组件挂载mounted就做一些逻辑处理，可以通过$emit来实现Parent.vue &lt;Child @mounted = \"toDoSomething\" /&gt; Child.vue mounted () { this.$emit(\"mounted\"); } 但是也有他的不足，那就是每次都需要手动写一次 $emit 触发父组件的事件而通过hook来监听生命周期则会更加方便简单 通过@hook实现 Parent.vue &lt;Child @hook:mounted = \"toDoSomething\" /&gt; toDoSomething () { console.log('Parent component listens to child component...') } Child.vue mounted () { console.log('child trigger hook...') } 输出顺序为：child trigger hook…Parent component listens to child component…子组件先执行被监听的生命周期的钩子函数，然后父组件执行监听到的钩子函数的方法","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"学习篇","slug":"技术篇/学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"},{"name":"vue-router","slug":"vue-router","permalink":"https://wangchuaichuai.github.io/tags/vue-router/"}],"author":"王小欣"},{"title":"vue-router使用query失效","slug":"vue-router传参query失效","date":"2021-12-07T04:37:00.000Z","updated":"2021-12-21T09:09:15.875Z","comments":true,"path":"posts/11b3fa24.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/11b3fa24.html","excerpt":"","text":"vue-router传参使用query失效vue在使用query传参后，第一次跳转数据是没问题的，但第二次刷新页面数据会变为[object object]，以下是解决方法之一。 要跳转的传参页先将数组转换为字符串 &lt;li v-for=\" ( list,index ) in indexcurr['curr'] \" :key=\"index\"&gt; &lt;router-link :to=\"{ path: '/detail', query: { id: JSON.stringify( list ), item: JSON.stringify( indexcurr ) }}\"&gt; &lt;/router-link&gt; &lt;/li&gt; 接收页面将字符串转为对象 created () { let obj1 = eval( '(' + this.$route.query.id + ')' ) let obj2 = eval( '(' + this.$route.query.item + ')' ) }, 这样就解决问题了，不要直接传数组与对象","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"学习篇","slug":"技术篇/学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"},{"name":"vue-router","slug":"vue-router","permalink":"https://wangchuaichuai.github.io/tags/vue-router/"}],"author":"王小欣"},{"title":"vue强制刷新某组件(销毁重置)","slug":"vue强制刷新组件","date":"2021-12-05T04:12:00.000Z","updated":"2021-12-21T09:09:10.689Z","comments":true,"path":"posts/10c30ac1.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/10c30ac1.html","excerpt":"","text":"vue强制刷新某组件(销毁重置)在需要强制刷新的组件中添加 v-if = \" hackReset \" 触发事件执行下面的代码 this.hackReset = false this.$nextTick ( () =&gt; { this.hackReset = true })","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"学习篇","slug":"技术篇/学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"},{"name":"vue-router","slug":"vue-router","permalink":"https://wangchuaichuai.github.io/tags/vue-router/"}],"author":"王小欣"},{"title":"vue-router传递参数的几种方式","slug":"vue-router传递参数的几种方式","date":"2021-12-03T04:37:00.000Z","updated":"2021-12-21T09:09:03.729Z","comments":true,"path":"posts/abc4aca3.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/abc4aca3.html","excerpt":"","text":"vue-router传参 vue-router传递参数可以分为 -[1] 编程式导航，route.push这种js中的跳转 -[2] 声明式导航，router-link 这种标签跳转 编程式导航 router.push传递的参数有两种：String字符串和Object对象 1. 字符串 直接将跳转的路由的地址写入即可，但是无法传递参数 this.$router.push('地址') 2. 对象 分为两种：命名路由和查询参数 2.1 命名路由命名路由的前提是在注册路由的地方给需要的路由命名name在其中对路由使用name属性命名路由传递参数需要使用params来传递，这里一定要注意使用params不是query。目标 页面接收传递参数时使用params注意使用params这种方式传递参数在刷新页面后传递的值会失效使用方法 this.$router.push({ //name中填写自己的命名即可 name: 'companyEdit', params:{ Id: 123 } }) 在需要取值的地方使用取值即可 2.2 查询参数查询参数其实就是在路由地址后面带上参数和传统的url参数一致的，传递参数使用query而且必须配合path来传递参数而不能用name，目标页面接收传递的参数使用query。查询参数使用的是query传递参数，切记name和params是一对，path和query是一对使用方法 this.$router.push({ //path填写自己的路径url即可 path: '/company/Edit', query:{ Id: 123 } }) 在需要取值的地方使用取值即可 声明式导航声明式导航和编程式导航的使用大同小异,只不过使用标签包裹罢了第一种： &lt;router-link to='company'&gt;跳转至/company&lt;/router-link&gt; 第二种： &lt;router-link :to=\"{ name: 'companyEdit', params: { Id: 123 } }\"&gt; 跳转至name为companyEdit的路由 &lt;/router-link&gt; 第三种： &lt;router-link :to=\"{ path: '/company/Edit', query: { Id: 123 } }\"&gt; 跳转至name为companyEdit的路由 &lt;/router-link&gt; 1.命名路由搭配params，刷新页面参数会丢失2.查询参数搭配query，刷新页面数据不会丢失3.接受参数使用this.$route后面就是搭配路由的名称就能获取到参数的值4.注意使用跳转的时候是$router，接收参数的时候是$route，千万不要写错","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"学习篇","slug":"技术篇/学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"},{"name":"vue-router","slug":"vue-router","permalink":"https://wangchuaichuai.github.io/tags/vue-router/"}],"author":"王小欣"},{"title":"解决vue 子组件修改父组件传来的props值报错问题","slug":"vue子组件直接修改父组件传来的props值报错","date":"2021-12-01T04:12:00.000Z","updated":"2021-12-21T09:08:56.775Z","comments":true,"path":"posts/34e4f0a2.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/34e4f0a2.html","excerpt":"","text":"解决vue 子组件修改父组件传来的props值报错问题首先要说明的一点便是，vue不推荐直接在子组件中修改父组件传来的props的值，会报错 [Vue warn]: Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop’s value. Prop being mutated: “result” (found in component ) 可以做一点变通，在子组件的data中在定义一个值来接收props，这样便不会报错了，如果需要改值得话还是通过父组件来改变而非子组件或者运用子向父传值得办法来改变","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"学习篇","slug":"技术篇/学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"},{"name":"vue-router","slug":"vue-router","permalink":"https://wangchuaichuai.github.io/tags/vue-router/"}],"author":"王小欣"},{"title":"vue-router获取meta","slug":"vue-router获取meta","date":"2021-11-29T04:12:00.000Z","updated":"2021-12-21T09:08:47.590Z","comments":true,"path":"posts/310d1d65.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/310d1d65.html","excerpt":"","text":"vue-router获取meta实习的时候遇到一个问题，在某个面包屑中动态切换值，显示添加与查看 { path: 'list', components: () =&gt; import ( '@components/list' ), meta: { ListName: 'add' } } 开始想着meta和prop一样可以传入route的参数，结果踩了一天雷后来想出两种办法第一种:配置两个路由，使用同一个组件 { path: 'list', components: () =&gt; import ( '@components/list/a' ), meta: { ListName: 'add' } } { path: 'list', components: () =&gt; import ( '@components/list/a' ), meta: { ListName: 'edit' } } 但是觉得太麻烦，便动态根据条件使用三目运算符来直接赋值标题了 {{ this.$route.query.id ? 'add' : 'edit' }} 暂时就这样处理吧~","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"学习篇","slug":"技术篇/学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"},{"name":"vue-router","slug":"vue-router","permalink":"https://wangchuaichuai.github.io/tags/vue-router/"}],"author":"王小欣"},{"title":"小程序无法播放本地视频","slug":"小程序本地视频无法播放","date":"2021-11-27T04:12:00.000Z","updated":"2021-12-21T09:08:41.793Z","comments":true,"path":"posts/f153a0d6.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/f153a0d6.html","excerpt":"","text":"小程序无法播放本地视频 小程序最好使用网络视频而非本地视频，否则会出现视频无法播放得问题 小程序中得video组件是原生组件，src属性默认支持mp4格式，实际上还可以支持其他格式 src: 要播放得视频得资源地址initial-time: 指定视频初始播放位置danmu-list: 弹幕列表controls: 是否显示默认播放控件(播放/暂停按钮、播放进度、事件)binderror: 视频播放出错时候得触发 使用wx.getSystemInfo获取系统信息 参数主要有brand: 手机品牌model: 手机型号fontSizeSetting: 用户字体大小设置pixelRatio: 设备像素比","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"学习篇","slug":"技术篇/学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"},{"name":"vue-router","slug":"vue-router","permalink":"https://wangchuaichuai.github.io/tags/vue-router/"}],"author":"王小欣"},{"title":"动态控制disabled","slug":"动态disabled","date":"2021-11-25T16:00:00.000Z","updated":"2021-11-27T13:54:54.172Z","comments":true,"path":"posts/7e9234b3.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/7e9234b3.html","excerpt":"","text":"动态控制disabled可以先设置一个值，使用v-bind来将disabled的值绑定到某个data数据或者props中的数据，在想要改变禁用与否的地方添加方法，将值取反即可在禁用与非禁用之间反复横跳，我将其定义在了判断输入框是否为空，为空则无法点击 如图一所示，进行一个绑定，对input输入框运用onblur方法来判定是否为空，为空置值为true否则为false方法如图二数据如图三 这样就可以进行事件操作了输入框为空则无法点击输入框有值则可以点击","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"},{"name":"JS","slug":"JS","permalink":"https://wangchuaichuai.github.io/tags/JS/"},{"name":"ElementUI","slug":"ElementUI","permalink":"https://wangchuaichuai.github.io/tags/ElementUI/"}],"author":"王小欣"},{"title":"vue的搜索框--elementUI","slug":"搜索框","date":"2021-11-24T16:00:00.000Z","updated":"2021-11-27T14:12:16.426Z","comments":true,"path":"posts/e08e7663.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/e08e7663.html","excerpt":"","text":"实现搜索框可以先在本地定义一个数组，定义一个方法来遍历接收到的数据，筛选其中的字来匹配对应的内容，筛选出来后放到本地的数组中并将其显示出来，在页面跳转后或者刷新的时候要将数组清空，否则可能会影响到其他页面的内容 取消 { item.product.title || item.news.title } 然后是定义的方法，searchAction中来从获取到的数据中遍历得到的数据并存放在自己定义的数组中，exit中定义的是清空数组，我为了方便便将exit事件放到了再次点击输入框进行了绑定 // 获取e，通过target.value获取值 searchAction(e) { let inputValue = e // 给空数组searchResult赋值 this.searchResult = this.courseData.filter((item) =&gt; { if ( item.product.title.includes(inputValue) || item.news.title.includes(inputValue) ) { return item } }) }, exit(){ this.searchResult = []; this.isShow = true; this.count1 = 0; this.count2 = 0 }, [![omcDqU.png](https://z3.ax1x.com/2021/11/27/omcDqU.png)](https://imgtu.com/i/omcDqU) 这样便能显示出对应的遍历后的数据了","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"},{"name":"JS","slug":"JS","permalink":"https://wangchuaichuai.github.io/tags/JS/"},{"name":"ElementUI","slug":"ElementUI","permalink":"https://wangchuaichuai.github.io/tags/ElementUI/"}],"author":"王小欣"},{"title":"vue的for循环一行两列","slug":"doublelist","date":"2021-11-23T16:00:00.000Z","updated":"2021-11-27T14:18:36.423Z","comments":true,"path":"posts/8370a851.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/8370a851.html","excerpt":"","text":"在使用vue的过程中，发现v-for这个指令渲染页面非常好用，但是循环的都是在一列上，显示效果很差，所以做成一行两列，实现办法只需要在一个循环体里面放置两个同样的格式，并且判断该循环的索引值和数组长度进行比较即可 {list.name} {lists[i+1].name}","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"},{"name":"JS","slug":"JS","permalink":"https://wangchuaichuai.github.io/tags/JS/"}],"author":"王小欣"},{"title":"vue文字很多时使用...代替","slug":"takeplace","date":"2021-11-22T16:00:00.000Z","updated":"2021-11-27T14:05:17.868Z","comments":true,"path":"posts/45d3758.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/45d3758.html","excerpt":"","text":"vue当文字很多的时候使用…代替代码如下，加入对应部位即可 .sub_title1{ overflow: hidden; white-space: nowrap; text-overflow: ellipsis; }修改后如图","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"},{"name":"JS","slug":"JS","permalink":"https://wangchuaichuai.github.io/tags/JS/"}],"author":"王小欣"},{"title":"el-popover修改样式","slug":"popover","date":"2021-11-21T16:00:00.000Z","updated":"2021-11-27T13:54:54.164Z","comments":true,"path":"posts/d850b7be.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/d850b7be.html","excerpt":"","text":"el-popover的样式的修改el-popover的class也是el-popover，他比较特别的是,el-popover生成的div不在当前组件之内，甚至不在App.vue组件的div内，他和App.vue组件的div平级，所以需要设置全局style。当然也不能用穿透符，因为组件不在当前组件内，也就没有穿透这一说了不加scoped就是全局style啦el-popover是和app是同级别的，弹窗属于全局样式，所以在scoped设置的样式是没有用的","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://wangchuaichuai.github.io/tags/JS/"},{"name":"ElementUI","slug":"ElementUI","permalink":"https://wangchuaichuai.github.io/tags/ElementUI/"}],"author":"王小欣"},{"title":"已安装对应模块，但报无法找到模块“XXX”的声明文件的解决方案","slug":"Nomodule","date":"2021-11-20T16:00:00.000Z","updated":"2021-11-27T13:54:54.156Z","comments":true,"path":"posts/8bcf08b0.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/8bcf08b0.html","excerpt":"","text":"已安装对应模块，但报无法找到模块“XXX”的声明文件的解决方案做项目的时候，导入某些组件的时候如果其他文件中包含了这些组件，可能会报如下错可以直接在src文件目录下创建一个shime-vue.d.ts文件，在里面写入 declare module ‘mint-ui’保存后就可以正常引入对应的组件或模块了","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"配置篇","slug":"技术篇/配置篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E9%85%8D%E7%BD%AE%E7%AF%87/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://wangchuaichuai.github.io/tags/JS/"}],"author":"王小欣"},{"title":"vue项目中的返回上一页","slug":"goBack","date":"2021-11-19T16:00:00.000Z","updated":"2021-11-27T13:54:54.162Z","comments":true,"path":"posts/3a5c711.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/3a5c711.html","excerpt":"","text":"vue项目中返回上一页 由于vue所生产的项目叫做SPA单页面应用，如果还是使用jQuery中的go(-1)或者back()是行不通的，所以我们用到了vue中的编程式导航 使用定义一个使用返回的按钮或者模块 &lt;el-page-header @back=”goBack” title=”” v-bind:content=”$route.name” class=”page_header” &gt; 在methods中定义该goBack方法 methods: { goBack() { if (window.history.length &lt;= 1) { this.$router.push({ path: ‘/‘ }) return false } else { this.$router.go(-1) } }, },","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"},{"name":"JS","slug":"JS","permalink":"https://wangchuaichuai.github.io/tags/JS/"}],"author":"王小欣"},{"title":"消除router-link 的下划线问题","slug":"router","date":"2021-11-18T16:00:00.000Z","updated":"2021-11-27T14:17:46.789Z","comments":true,"path":"posts/763e2e06.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/763e2e06.html","excerpt":"","text":"消除router-link 的下划线问题使用router-link实现路由跳转，代码如下： {list.title} 虽然能实现跳转了，但是文字带有了下划线，不好看 要消除下划线，增加一下样式代码即可： .router-link-active { text-decoration: none; }如果给link加了选择器也可以通过选择器来选中设置该样式 效果如下","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"},{"name":"JS","slug":"JS","permalink":"https://wangchuaichuai.github.io/tags/JS/"},{"name":"vue-router","slug":"vue-router","permalink":"https://wangchuaichuai.github.io/tags/vue-router/"}],"author":"王小欣"},{"title":"el-tabs添加滚动条","slug":"tabs","date":"2021-11-17T16:00:00.000Z","updated":"2022-03-14T12:43:44.234Z","comments":true,"path":"posts/2a3e1185.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/2a3e1185.html","excerpt":"","text":"el-tabs添加滚动条element-ui的el-tabs默认是没有滚动条的，可在 el-tab-pane上添加： &lt;el-tab-pane style=\"height:90%;overflow-y:auto;overflow-x:hidden;\"&gt;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://wangchuaichuai.github.io/tags/JS/"},{"name":"ElementUI","slug":"ElementUI","permalink":"https://wangchuaichuai.github.io/tags/ElementUI/"}],"author":"王小欣"},{"title":"composition API","slug":"Composition API","date":"2021-11-17T04:37:00.000Z","updated":"2021-11-17T11:01:39.675Z","comments":true,"path":"posts/909b49ba.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/909b49ba.html","excerpt":"","text":"setup新的option，所有的组合API函数都在此使用，且只在初始化时执行一次 函数如果返回对象，对象种的属性或方法，模板种可以直接使用 程序执行会先进入到setup方法当中，是组合API的入口 ## 执行时机 在beforeCreate之前执行，此时对象还没有被创建 ## setup的两个参数props和context props:是一个对象，看props的文档，封装所有接收到的属性 context:是一个对象 里面有attrs对象(获取当前组件标签上的所有属性 但是该属性是在props中没有声明接收的所有的尚需经的对象) emit方法(分发事件的)，slots对象(插槽) refref是一个函数，作用：定义一个响应式数据 返回的是一个Ref对象，对象种有有个value属性 如果需要对数据进行操作，需要使用该Ref对象调用value属性的方式进行数据操作 html中是不需要.value写法的，但是在更改元素的script标签中是需要通过.value获取元素的 reactive定义多个响应式数据 const proxy = reactive(obj):接收一个普通对象然后返回该普通对象的响应式代理器对象 setup(){ const user = reactive({ name:'ww', age:2, }), return { user, } } reactive和ref对比ref是用来处理基本数据类型的，reactive是用来处理对象(递归深度响应式) 如果用ref对象/数组，内部会自动将对象转为reactive的代理对象 ref内部:通过给value属性添加getter/setter来实现对数据的劫持 reactive内部:通过使用proxy来实现对对象内部所有数据的劫持，并通过reflect操作对象内部数据 ref的数据操作:在js中要.value，在模板中不需要 toRefs把一个响应式对象转换成普通对象，普通对象的每一个property都是一个ref 利用toRefs可以将一个响应式reactive对象的所有原始属性转为响应式的ref属性","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"学习篇","slug":"技术篇/学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"},{"name":"composition","slug":"composition","permalink":"https://wangchuaichuai.github.io/tags/composition/"},{"name":"特性","slug":"特性","permalink":"https://wangchuaichuai.github.io/tags/%E7%89%B9%E6%80%A7/"}],"author":"王小欣"},{"title":"proxy跨域代理","slug":"proxy跨域代理","date":"2021-11-17T04:37:00.000Z","updated":"2021-11-17T11:20:56.719Z","comments":true,"path":"posts/7670789a.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/7670789a.html","excerpt":"","text":"接口的跨域问题vue项目运行在http:8080端口 API接口在https中，需要跨域请求 由于API接口没有开启CORS跨域资源共享，默认情况下接口无法请求成功 解决1.把axios的请求根路径设置为vue项目的运行地址，使接口请求不在跨域 2.vue项目发现请求的接口不存在，把请求转交给proxy代理 3.代理把请求更路径替换为devServer.proxy属性的值，发起正在的数据请求 4.代理把请求到的数据转发给axios","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"报错篇","slug":"技术篇/报错篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E6%8A%A5%E9%94%99%E7%AF%87/"},{"name":"学习篇","slug":"技术篇/报错篇/学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E6%8A%A5%E9%94%99%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"},{"name":"跨域","slug":"跨域","permalink":"https://wangchuaichuai.github.io/tags/%E8%B7%A8%E5%9F%9F/"}],"author":"王小欣"},{"title":"插槽","slug":"插槽","date":"2021-11-17T04:37:00.000Z","updated":"2021-11-17T11:02:32.539Z","comments":true,"path":"posts/acd91e5d.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/acd91e5d.html","excerpt":"","text":"插槽基础插槽是预留给用户的占位符 再封装组件时，可以通过&lt;slot&gt;元素定义插槽，从而为用户预留内容占位符 &lt;template&gt; &lt;p&gt;这是第一个p标签&lt;/p&gt; &lt;slot&gt;&lt;/slot&gt; &lt;p&gt;这是最后一个p标签&lt;/p&gt; &lt;/template&gt; &lt;my-com&gt; &lt;p&gt;用户自定义内容&lt;/p&gt; &lt;/my-com&gt; 具名插槽如果再封装组件的时候需要预留多个插槽节点 则需要为每个&lt;slot&gt;插槽指定具体的name名称，这种带有具体名称的插槽叫做具名插槽 &lt;slot name=\"header\"&gt;&lt;/slot&gt; 默认只有一个名字叫default v-slot也有缩写，缩写为#号 作用域插槽在封装组件的过程中，可以为预留的slot插槽绑定props数据 这种带有props数据&lt;slot&gt;叫做作用域插槽 &lt;div&gt; &lt;h3&gt;这是组件&lt;/h3&gt; &lt;slot :info=\"infomation\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;my-test&gt; &lt;template v-slot:default=\"scope\"&gt; {{ scope }} &lt;/template&gt; &lt;/my-test&gt;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"学习篇","slug":"技术篇/学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"},{"name":"特性","slug":"特性","permalink":"https://wangchuaichuai.github.io/tags/%E7%89%B9%E6%80%A7/"},{"name":"插槽","slug":"插槽","permalink":"https://wangchuaichuai.github.io/tags/%E6%8F%92%E6%A7%BD/"}],"author":"王小欣"},{"title":"编程式导航","slug":"编程式导航","date":"2021-11-17T04:37:00.000Z","updated":"2021-11-17T11:20:56.724Z","comments":true,"path":"posts/91b1abfc.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/91b1abfc.html","excerpt":"","text":"编程式导航通过调用API实现导航的方式，叫做编程式导航 通过点击链接实现导航的方式叫做声明式导航 ex: 普通页面点击&lt;a&gt;链接，vue中点击&lt;vue-link&gt;属于声明式导航 普通页面中调用location.href跳转到新页面属于编程式导航 vue-router中的编程式导航APIvue-router提供了许多编程式导航的API 最常用的两个是： 1.this.$router.push('hash地址') 跳转到指定Hash地址从而展示对应的组件 2.this.$router.go(数值n)，-1为后退 实现导航历史的前进、后退 命名路由通过name属性为路由规则定义名称的方式 ps:命名路由的name不能重复，必须保证唯一性，同params接收数据","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"学习篇","slug":"技术篇/学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"},{"name":"导航","slug":"导航","permalink":"https://wangchuaichuai.github.io/tags/%E5%AF%BC%E8%88%AA/"}],"author":"王小欣"},{"title":"宏任务和微任务","slug":"宏任务和微任务","date":"2021-11-16T04:37:00.000Z","updated":"2021-11-17T11:02:48.561Z","comments":true,"path":"posts/e9e40021.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/e9e40021.html","excerpt":"","text":"宏任务和微任务宏任务异步ajax请求 setTimeout(延时器)、setInterval(定时器) 文件操作 其他宏任务 微任务promise.then、.catch和.finally process.nextTick 其他微任务 执行顺序先执行宏任务，执行结束后查询是否有微任务 执行完队列中所有的微任务后执行下一个宏任务，若无微任务执行下一个宏任务 每一个宏任务执行完后都会检查是否有微任务","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"学习篇","slug":"技术篇/学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"宏任务","slug":"宏任务","permalink":"https://wangchuaichuai.github.io/tags/%E5%AE%8F%E4%BB%BB%E5%8A%A1/"},{"name":"微任务","slug":"微任务","permalink":"https://wangchuaichuai.github.io/tags/%E5%BE%AE%E4%BB%BB%E5%8A%A1/"}],"author":"王小欣"},{"title":"组件库","slug":"组件库","date":"2021-11-16T04:37:00.000Z","updated":"2021-11-17T10:54:09.011Z","comments":true,"path":"posts/45451bcc.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/45451bcc.html","excerpt":"","text":"PC端常用Element UI https://element.eleme.cn/#/zh-CN vue2:https://element.eleme.cn/#/zh-CN npm i element-ui -S vue3:https://element-plus.gitee.io/#/zh-CN View UI http://v1.iviewui.com/ 移动端(都常用)Mint UI https://mint-ui.github.io/#!/zh-cn Vant https://vant-contrib.gitee.io/vant/#/zh-CN/ 完整导入//完整导入ui组件 import ElementUI from 'element-ui' //导入ui组件样式 import 'element-ui/lib/theme-chalk/index.css' //把ui注册为vue的插件，注册之后，可以在每个组件中直接使用ui的组件 Vue.use(ElementUI) 按需引入借助babel-plugin-component，可以只引入需要的组件，达到减小项目体积的目的 1.安装babel-plugin-component npm install babel-plugin-component -D 2.修改根目录下babel.config.js的配置文件，新增plugins节点 plugins:[ [ 'component', { libraryName:'element-ui', styleLibraryName:'theme-chalk', } ] ] 3.引入对应组件部分(引入Button) import { Button } from 'element-ui' Vue.component(Button.name,Button) //可以写成Vue.use(Button) 把组件的导入和注册封装为独立的模块在src目录下新建element-ui/index.js模块 import Vue from 'vue' import { Button } from 'element-ui' Vue.use(Button) 在main.js中导入 import './element-ui' loading效果导入效果组件 声明变量存储loading组件的实例对象 let loadingInstance = null 在拦截器中使用loading组件 loadingInstance = Loading.service({ fullscreen : true }) loadingInstance.close()关闭组件","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"学习篇","slug":"技术篇/学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"组件","slug":"组件","permalink":"https://wangchuaichuai.github.io/tags/%E7%BB%84%E4%BB%B6/"}],"author":"王小欣"},{"title":"ES6模块化规范","slug":"ES6模块化规范","date":"2021-11-15T04:37:00.000Z","updated":"2021-11-17T11:04:24.821Z","comments":true,"path":"posts/185539cd.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/185539cd.html","excerpt":"","text":"ES6模块化规范每个js文件都是一个独立的模块 导入其他模块成员使用import关键字 向外共享模块成员使用export关键字 let关键字let取代var，使用let后变量名不能重复，不会预处理，不存在变量提升 进行变量提升是在预处理中进行的，说的就是预处理的过程 js代码执行之前要进行一次预处理，预解析 找两个东西一个var，一个function 找到var，对后面的东西进行赋值 找到function后提前将函数定义好 const关键字定义之后无法改变 变量的解构和赋值理解：从对象或数组中提取数据，并赋值给变量(多个) 1.对象的解构赋值 let{n,a} = {n:'tom',a:12} 2.数组的解构赋值 let[n,a] = [1,'aaa'] let[a,b] = [,1]//按照下标取值,可以用,来隔开取后面的 模板字符串，解决字符串拼接输出的问题，不用频繁+和引号模板字符串必须用``包含 变化的部分使用${XXX}来定义 简化的对象写法同名的属性可以省略 ex: let us = 'haha' let b = '1' let obj = { //us = us //b = b 同名，直接替换 us,b } 箭头函数，简化函数传统： var fun4 = function(){ xxx } 改版： let fun4 = (这里面放参数) =&gt; {语句} 若参数和语句只有一条，可以省略()或者{}，若函数体和形参不止一个不能省略 特点： 1.简介 2.箭头函数没有自己的this 箭头函数的this不是调用的时候决定的 而是在定义的时候处在的对象就是它的this 3.如果没有外层函数，this是window 如果有，this是外层函数 外层函数的普通函数，就看谁调用它，this就是谁 点点点(…)运算符(获取内部所有字符)1.rest可变参数，用来取代arguments 2.function fun(...values){ console.log(values) values.forEach(function (item,index){ console.log(item,index) }) }//遍历，获取所有参数 2.扩展运算符 let arr = [1,6] let arr1 = [2,3,4,5] arr = [1,...arr1,6] promise解决地狱回调问题看promise文件夹 symbol新增的原始数据类型(解决唯一性)需要使用方法来创建,用数组来添加 let symbol = Symbol() obj[symbol] = 'hello' 还可以用来定义常量 const Person_key = Symbol('person_key') Generator函数，解决异步编程的方案之一1.是一个状态机，内部封装了不同状态的数据 2.用来生成遍历器对象 3.可暂停函数(惰性求值),yield可暂停 next可启动 每次返回的是yield后的表达式结果 特点： function与函数名之间有一个星号 内部用yield表达式来定义不同的状态 ex:function* myGenerator(){ yield 'hello' } let MG = myGenerator() MG.next() async来进一步提高异步编程generator函数class的定义class Person{ constructor(name,age){//类的构造方法 this.name = name; this.age = age; } showName(){//类的一般方法 console.log() } } let person = new Person('kk',39) person.showName class StarPerson extends Person{ constructor(name,age,salary){ super(name,age)//写了这个表明调用了父类的方法 this.salary = salary } } 字符串数组的扩展1.includes(str)判断是否包含指定字符串 2.startsWith(str)判断是否以指定字符串开头 3.endsWith(str)判断是否以指定字符串结尾 4.repeat(count)重复指定次数","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"学习篇","slug":"技术篇/学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://wangchuaichuai.github.io/tags/ES6/"},{"name":"规范","slug":"规范","permalink":"https://wangchuaichuai.github.io/tags/%E8%A7%84%E8%8C%83/"}],"author":"王小欣"},{"title":"less","slug":"less","date":"2021-11-15T04:37:00.000Z","updated":"2021-11-17T10:10:18.536Z","comments":true,"path":"posts/d3b694df.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/d3b694df.html","excerpt":"","text":"less使用需要把less预处理为css然后使用到网页中 //不会被编译到css中 /**/会被编译到css中，//是给开发人员开的 less中的变量使用@来申明一个变量 @pink:pink 1.作为普通属性值只用来使用：直接使用@pink 2.作为选择器和属性名：#@{selector的值}的形式 3.作为URL：@{url} 4.变量的延迟加载 less嵌套1.父子是嵌套 2.&amp;是平级 混合提取公共代码 提取出来的东西类似函数，但是叫混合 变量后面加冒号是默认值","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"学习篇","slug":"技术篇/学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"Less","slug":"Less","permalink":"https://wangchuaichuai.github.io/tags/Less/"}],"author":"王小欣"},{"title":"JS小记录","slug":"JS随笔","date":"2021-11-14T04:37:00.000Z","updated":"2021-11-17T10:10:18.529Z","comments":true,"path":"posts/831f1623.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/831f1623.html","excerpt":"","text":"JS相关问题回调函数1.你定义的 2.你没有调用 3.最终都执行了 ex:定时器执行操作，定义了，没有调用，时间到后最终执行了 ex:dom事件回调函数，你定义了一个绑定点击的事件，没有手动添加执行，而是点击才执行，最终也执行了这个函数 常用的回调函数1.dom事件回调函数 2.定时器回调函数 3.ajax请求回调函数 4.声明周期回调函数 如何确定this的值1.test():window 直接调用 2.p.test():p 用p去调用 3.new test():新创建的对象 4.p.call(obj):obj js中独有的，将任意方法赋予其他类型 JSON和JS相互转换1.JSON.stringify(obj/arr) js转json 2.JSON.parse(json) json转js 将函数内部的this绑定为指定的对象var obj = {username:'kkk'} function foo(data){} foo.call(obj,33) foo.apply(obj,[33]) foo.bind(obj,33)()用自调用或者重新调用 var a = foo.bind(obj,33) a() 1.bind() 2.call() 3.apply() 在不传参的情况下，call和apply是一样的,apply参数必须放在数组中，而bind的特性是绑定完后会把函数返回 预处理和变量提升进行变量提升是在预处理中进行的，说的就是预处理的过程，js代码执行之前要进行一次预处理，预解析，找两个东西，一个var，一个function，找到var，对后面的东西进行赋值，找到function后提前将函数定义好","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"学习篇","slug":"技术篇/学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://wangchuaichuai.github.io/tags/JS/"}],"author":"王小欣"},{"title":"axios配置","slug":"axios配置","date":"2021-11-14T04:37:00.000Z","updated":"2021-11-17T10:54:08.988Z","comments":true,"path":"posts/a01ef157.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/a01ef157.html","excerpt":"","text":"全局配置axios发起ajax请求在main.js入口文件中，通过app.config.globalProperties全局挂载axios ex: axios.defaults.baseURL = 'http://api.com' app.config.globalProperties.$http = axios this.$http.get('/user') this.$http.post('/count') ps:$http可以换成自己任意的名字 baseURL配置的是基本路径 配置请求拦截器 //有一个成功和一个失败的回调，失败可以省略，成功必须return config axios.interceptors.request.use(config = { return config }) 配置响应拦截器 axos.interceptors.response.use(function (response{ return response; })) vue2中全局配置axiosaxios.defaults.baseURL = 'https://www.escook.cn' //通过Vue构造函数的原型对象全局配置axios Vue.prototype.$http = axios","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"学习篇","slug":"技术篇/学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://wangchuaichuai.github.io/tags/JS/"}],"author":"王小欣"},{"title":"ES6-yield","slug":"ES6 yield","date":"2021-11-13T04:37:00.000Z","updated":"2021-11-17T10:10:18.532Z","comments":true,"path":"posts/a6439255.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/a6439255.html","excerpt":"","text":"ES6 yield介绍yield 关键字用来暂停和继续一个生成器函数。我们可以在需要的时候控制函数的运行。yield 关键字使生成器函数暂停执行，并返回跟在它后面的表达式的当前值。与return类似，但是可以使用next方法让生成器函数继续执行函数yield后面内容，直到遇到yield暂停或return返回或函数执行结束。 使用函数返回对象包括value和done。其中value值是yield后面表达式值或return后面表达式值。done用于表示函数运行 function* get() { //声明时需要添加*，普通函数内部不能使用yield关键字， //否则会出错 yield ‘1’; return ‘2’;} var a = get(); //调用函数后不会运行，而是返回指向函数内部状态的指针 a.next(); // { value: '1', done: false } 遇到yield暂停 a.next(); // { value: '2', done: true} 函数执行完毕，返回done a.next(); // { value: undefined, done: true} 已经执行完毕，返回undefined 如果next没有带有参数true，yield不能返回值，返回undefined；next函数带有参数true，即.next(true)时，那么yield就可以返回表达式的值，用于赋值。如果next带有其他参数，那么它就会将当前yield返回值置为该参数 搭配异步函数在遇到yield后暂停运行，我们可以在需要的地方使用next让它继续运行。并且必要时可以使用next传入参数。","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"学习篇","slug":"技术篇/学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://wangchuaichuai.github.io/tags/ES6/"},{"name":"yield","slug":"yield","permalink":"https://wangchuaichuai.github.io/tags/yield/"}],"author":"王小欣"},{"title":"Redux-saga","slug":"redux-saga","date":"2021-11-13T04:37:00.000Z","updated":"2021-11-17T10:10:18.542Z","comments":true,"path":"posts/5cd8cdf7.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/5cd8cdf7.html","excerpt":"","text":"redux-saganpm install -save redux-saga yarn add redux-saga 为了能跑起 Saga，我们需要使用 redux-saga 中间件将 Saga 与 Redux Store 建立连接。main.js import { createStore,applyMiddleware } from 'redux' import createSagaMiddleware from 'redux-saga' import sagas from '路径' const sagaMiddleware = createSagaMiddleware() const store = createStore( reducer, applyMiddleware(sagaMiddleware) ) sagaMiddleware.run(mySaga) export default store 写generator函数,拦截dispatch//从effects里面解构出来takeEvery来使用 import { takeEvery,put } from 'redux-saga/effects' function * sagaAsync(){ yiel put( {type:'add',data:0 }) } //接收所有的dispatch对应的action的请求 func * sagas(){ yield takeEvery('sagaAdd',sagaAsync) } export default sagas 这样一个基本的saga使用就完成了,put里面执行的是真正的dispatch，takeEvery里面只是接收,如果两个方法名字重名的话可能会导致无限循环","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"学习篇","slug":"技术篇/学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://wangchuaichuai.github.io/tags/Redux/"},{"name":"Redux-saga","slug":"Redux-saga","permalink":"https://wangchuaichuai.github.io/tags/Redux-saga/"}],"author":"王小欣"},{"title":"CSSTransitionGroup","slug":"CSSTransitionGroup","date":"2021-11-12T04:37:00.000Z","updated":"2021-11-17T10:53:40.511Z","comments":true,"path":"posts/df140f5b.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/df140f5b.html","excerpt":"","text":"css动画之CSSTransitionGroup当一个React组件添加或者移除一个DOM的时候可以轻易的实现CSS动画。 路由动画react-transition-groupyarn add react-transition-group -S npm install react-transition-group -S 解构import {CSSTransition} from 'react-transition-group' 使用&lt;CSSTransition&gt;&lt;/CSSTransition&gt;来包裹触发的内容 render(){ return ( &lt;div&gt; &lt;CSSTransition in={ this.state.show }//状态信息 timeout={ 200 }//时间 classNames=\"my-node\"//样式 mountOnEnter//消失 unmountOnExit//出现 &gt; &lt;div&gt;hello&lt;/div&gt; &lt;/CSSTransition&gt; &lt;button onClick={ this.方法 }&gt;click&lt;/button&gt; &lt;/div&gt; ) } 样式属性[样式属性](https://reactcommunity.org/react-transition-group/) 动画组必须是已经挂载了才会起作用为了给CSSTransitionGroup的子级DOM添加动画效果 我们的CSSTransitionGroup必须是挂载到了DOM中了 或者transitionAppear必须设置为true。 安装CSS动画库1. npm install animate.css --save yarn add animate.css 2. 引入项目 import 'animate.css' 3. &lt; CSSTransition classNames=\"my-node\"//样式 &gt; &lt;div&gt;hello&lt;/div&gt; &lt;/CSSTransition&gt; 替换classNames为其中的需要的样式，名字按照官网自行找到需要的样式, 若要搭配appear的动画， 则需要在&lt;CSSTransition&gt;标签中添加appear={true}&lt;/CSSTransition&gt; 官网： [animate](https://animate.style/) classNames={{ appear:'my-appear', appearActive:'my-active-appear', appearDone:'my-done-appear', enter:'my-enter', enterActive:'my-active-enter', enterDone:'my-done-enter', exit:'my-exit', exitActive:'my-active-exit', exitDone:'my-done-exit', }}","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"学习篇","slug":"技术篇/学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wangchuaichuai.github.io/tags/css/"},{"name":"路由动画","slug":"路由动画","permalink":"https://wangchuaichuai.github.io/tags/%E8%B7%AF%E7%94%B1%E5%8A%A8%E7%94%BB/"}],"author":"王小欣"},{"title":"Mobx","slug":"mobx","date":"2021-11-12T04:37:00.000Z","updated":"2021-11-17T10:10:18.540Z","comments":true,"path":"posts/2a423ca.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/2a423ca.html","excerpt":"","text":"mobx依赖：npm i mobx -S、npm i mobx-react -S 装饰器语法npm i @babel/plugin-proposal-decorators -Dnpm i @babel/plugin-proposal-class-properties -D 使用babel插件\"babel\":{ \"plugins\":[ [\"@babel/plugin-proposal-decorators\",{\"legacy\":true}], [\"@babel/plugin-proposal-class-properties\",{\"loose\":true}] ] } ESLint配置\"eslintConfig\":{ \"parserOptions\":{ \"ecmaFeatures\":{ \"legacyDecorators\":true } } } 链接通过mobx-react中的Provider来连接mobx和react并在想使用数据的地方用标签来包裹起来 使用mobx","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"学习篇","slug":"技术篇/学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"mobx","slug":"mobx","permalink":"https://wangchuaichuai.github.io/tags/mobx/"}],"author":"王小欣"},{"title":"vue脚手架报错","slug":"vue报错","date":"2021-11-11T12:54:00.000Z","updated":"2021-11-17T10:18:13.913Z","comments":true,"path":"posts/fa8124b5.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/fa8124b5.html","excerpt":"","text":"一、Vue3.0 脚手架报错： [vue/no-multiple-template-root] The template root requires exactly one element. eslint-plugin-vue 查看问题 (⌥F8) 没有可用的快速修复 百度翻译： [vue/无多个模板根目录]模板根目录只需要一个元素。 eslint-plugin-vue 查看问题 (⌥（F8）没有可用的快速修复 二、解决办法查阅资料是插件 Vetur 还没兼容到最新版vue语法；通过设置 搜索 eslint-plugin-vue， 取消校验勾选即可。","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"报错篇","slug":"技术篇/报错篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E6%8A%A5%E9%94%99%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"}],"author":"王小欣"},{"title":"React Hooks","slug":"React Hooks","date":"2021-11-11T04:37:00.000Z","updated":"2022-03-20T03:33:59.825Z","comments":true,"path":"posts/712433a6.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/712433a6.html","excerpt":"","text":"1.useState保存组件得状态格式 let [state的名称,方法名] = useState(初始值) let [count,setCount] = useState(1)useState不帮助处理状态，相较于setState非覆盖式更新状态，useState覆盖式更新状态，需要我们自己处理逻辑 2.useEffect处理副作用useEffect的第二个参数表示依赖的值 如果第二个参数是一个空数组，则表示不依赖任何值 只在第一次执行且只执行一次，可类比componentDidMount 若传入参数则表示依赖其值的变化。 let [data,setData] = useState({count:0}) useEffect(() =&gt;{ console.log('effect') },[]) //去替代一些生命周期函数 useEffect(()=&gt;{ //ajax操作可以放在这里 console.log('mounted') return () =&gt;{ console.log('unmount') } },[]) return ( &lt;div&gt;{data.count}&lt;/div&gt; ) 3.useContext减少组件层级React封装好的处理多层级传递数据的方法 let name = createContext({name:'zz'}) let age = createContext({age:12}) function UseContext(){ let name = useContext(name) let age = useContext(age) return( &lt;div&gt; { name.name } { age.age } &lt;/div&gt; ) } 4.useReducer代替Redux中得Reducer在使用上几乎和Redux/React-Redux一模一样 唯一缺少的就是无法使用redux提供的中间件 const init = { count :0 } const reducer = (State,action)=&gt;{ switch(action.type){ case 1: case 2: default: } } function UseReducer(){ //useReducer需要俩参数，定义的reducer和初始值，并且返回state和dispatch,可以用[]来解构 let [state,dispatch] = useReducer(reducer,init) return ( &lt;div&gt; &lt;button onClick={ () =&gt; dispatch( { type:'1' } ) }&gt;&lt;/button&gt; &lt;button onClick={ () =&gt; dispatch( { type:'2' } ) }&gt;&lt;/button&gt; &lt;span&gt;{ state.count }&lt;/span&gt; &lt;/div&gt; ) } 5.useCallback记忆函数使用useCallback可以获得一个记忆后的函数来帮助我们减少未变化的组件的渲染 搭配React.memo，用memo将想要缓存的组件包裹起来 import {memo} from 'react const Child = memo( function ( props ) { console.log('child') return ( &lt;div&gt; &lt;h1&gt;hello&lt;/h1&gt; &lt;button onClick = { props.onAdd }&gt;add&lt;/button&gt; &lt;/div&gt; )},() =&gt;{ return true }//第二个参数，如果为true则不执行，可以通过复杂逻辑来判断子组件是否来进行缓存 ) export default function UseCallback() { let [ count,setCount ] = useState(0) const handleAdd = useCallback( () =&gt; { console.log('add') },[] ) return ( &lt;div&gt;{count}&lt;/div&gt; &lt;Child onAdd = {handleAdd}&gt;&lt;/Child&gt; &lt;button onClick = { () =&gt; setCount(100) }&gt;change&lt;/button&gt; ) } 6.useMemo记忆组件useCallback的功能完全可以由useMemo所取代 如果想通过useMemo返回一个记忆函数也是可以的 唯一的区别是：useCallback不会执行第一个参数函数，而是将它返回给你 而useMemo会执行第一个函数并将函数执行结果返回给你 所以useCallback常用记忆事件函数，生成记忆后的事件函数并传递给子组件使用 而useMemo更适合经过函数计算得到一个确定的值，比如记忆组件 function Parent( {a,b} ){ const child1 = useMemo ( () =&gt; () =&gt; &lt;Child a={a}/&gt;,[a]); const child1 = useMemo ( () =&gt; () =&gt; &lt;Child b={b}/&gt;,[b]); return ( &lt;div&gt; { child1 } { child2 } &lt;/div&gt; ) } 7.memoization仅在输入变化的时，重新计算render需要使用的值---memoization 在函数式组件中，中间件memoize要放到组件外部，否则会重复调用，无法缓存 import memoize from \"memoize-one\" const getString = memoize((str) =&gt; { console.log(1) return str + '3' }) const Child = function(props) { return ( &lt;div&gt; {getString(props.title)} &lt;/div&gt; ) } function Memoization(){ let [title,setTitle] = useState('hello') return ( &lt;div&gt; &lt;Child title = 'wa'&gt;&lt;/Child&gt; &lt;button onClick={()=&gt;setTitle('hello+')}&gt;change&lt;button&gt; &lt;/div&gt; ) } 在class中则不需要 8.useRef保存引用值import {createRef,useRef} from 'react' function UseRef(){ const btn = createRef()//旧版定义 const btn2 = useRef()//新版定义 return ( &lt;div&gt; &lt;button ref={btn}&gt;click&lt;/button&gt; &lt;/div&gt; ) } [1] useRef返回得值传递给组件或者DOM得ref属性，就可以通过ref.current值访问组件或真实得DOM节点，重点是组件也是可以访问到得 [2]利用useRef就可以绕过Capture Value得特性，可以认为ref在所有Render过程中保持着唯一引用，因此所有对ref的赋值或取值，拿到的都只有一个最终状态，而不会在每个Render间存在间隔 [3]将赋值与取值得对象编程useRef，而不是useState，就可以躲过capture value特性，在最后得到最新的值 function App(){ const count = useRef(0) const showCount = () =&gt;{ console.log(\"count: \"+ count.current) } const handleClick = number =&gt; { count.current = count.current + number; setTimeout(showCount,3000) } return ( &lt;div&gt; &lt;p&gt;{count.current}&lt;/p&gt; &lt;button onClick={()=&gt;handleClick(1)}&gt;增加&lt;/button&gt; &lt;button onClick={()=&gt;handleClick(-1)}&gt;减少&lt;/button&gt; &lt;/div&gt; ) } 9.自定义Hooks定义一个自定义的Hook需要use打头，比如useCount.js，且函数内部可以调用其他Hook 10.useImperativeHandle透传Ref11.useLayoutEffect同步执行副作用12.useEffect和useLayoutEffect的区别调用时机不同，后者在react完成DOM更新后马上同步调用代码，会阻塞页面的渲染，而useEffect是会在整个页面渲染完才会调用代码官方建议优先使用useEffect在实际使用的时候如果想避免页面抖动(在useEffect里修改DOM很有可能出现)的化，可以把需要操作DOM的代码放在useLayoutEffect里。不过useLayoutEffec在服务器渲染的时候会出现一个warning，要消除的化得用useEffect代替或者推迟渲染时机。","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"}],"tags":[{"name":"React","slug":"React","permalink":"https://wangchuaichuai.github.io/tags/React/"}],"author":"王小欣"},{"title":"mysql","slug":"MySql","date":"2021-11-10T00:37:00.000Z","updated":"2021-11-11T12:36:46.724Z","comments":true,"path":"posts/9520183a.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/9520183a.html","excerpt":"","text":"登录MySqlmysql -uroot -p 基础命令1、显示数据库列表。show databases;2、显示库中的数据表：use mysql； ／／打开库show tables;3、显示数据表的结构：describe 表名;4、建库：create database 库名; GBK: create database test2 DEFAULT CHARACTER SET gbk COLLATE gbk_chinese_ci;UTF8: CREATE DATABASE test2 DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;5、建表：use 库名；create table 表名(字段设定列表)；6、删库和删表:drop database 库名;drop table 表名；7、将表中记录清空：delete from 表名; truncate table 表名;8、显示表中的记录：select * from 表名; 9、编码的修改如果要改变整个mysql的编码格式：启动mysql的时候，mysqld_safe命令行加入–default-character-set=gbk 如果要改变某个库的编码格式：在mysql提示符后输入命令alter database db_name default character set gbk; 10.重命名表 alter table t1 rename t2; 11.查看sql语句的效率 explain &lt; table_name &gt; 例如：explain select * from t3 where id=3952602; 12.用文本方式将数据装入数据库表中(例如D:/mysql.txt) mysql&gt; LOAD DATA LOCAL INFILE “D:/mysql.txt” INTO TABLE MYTABLE;","categories":[{"name":"配置篇","slug":"配置篇","permalink":"https://wangchuaichuai.github.io/categories/%E9%85%8D%E7%BD%AE%E7%AF%87/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://wangchuaichuai.github.io/tags/linux/"},{"name":"mysql","slug":"mysql","permalink":"https://wangchuaichuai.github.io/tags/mysql/"}],"author":"王小欣"},{"title":"懒加载","slug":"懒加载","date":"2021-11-09T05:39:00.000Z","updated":"2021-11-11T12:32:33.131Z","comments":true,"path":"posts/3d72a2c2.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/3d72a2c2.html","excerpt":"","text":"懒加载将路由通过Suspense标签包裹， 并通过lazy懒加载的方式导入对应的文件来进行代码分割，选择性的重新渲染整个页面，这样就不必在渲染的同时再和页面上的其他元素进行交互。这样可以在点击对应的模块的时候去获取对应的资源","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"}],"tags":[{"name":"react-router","slug":"react-router","permalink":"https://wangchuaichuai.github.io/tags/react-router/"},{"name":"react","slug":"react","permalink":"https://wangchuaichuai.github.io/tags/react/"}],"author":"王小欣"},{"title":"连接池url时区陷阱","slug":"mysql jdbc url 时间_mysqlJDBC连接池url时区陷阱","date":"2021-11-09T05:37:00.000Z","updated":"2021-11-11T12:34:50.395Z","comments":true,"path":"posts/a859f83a.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/a859f83a.html","excerpt":"","text":"mysql jdbc url 时间_mysqlJDBC连接池url时区陷阱在使用mysql的6.0.x以上的jar的时候，需要在代码url的链接里面指定serverTimezone。否则就会出现异常。 如果在url中未指定serverTimezone url: jdbc:mysql://127.0.0.1:3306/spring_boot_quick?useUnicode=true&amp;characterEncoding=utf-8 则会出现：Caused by: com.mysql.cj.core.exceptions.InvalidConnectionAttributeException: The server time zone value ‘�й���׼ʱ��’ is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support 此异常 因为之前这种问题确实没有遇到过，因为google后，找到的答案是在url后面加上参数?serverTimezone=utc eg:url: jdbc:mysql://127.0.0.1:3306/spring_boot_quick?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false 此时虽然服务可以正常启动了，程序不报错了，但是又会有新的问题发生，就是我们在用java代码插入到数据库时间的时候却出现了问题。 比如在java代码里面插入的时间为：2019-04-12 13:29:56 但是在数据库里面显示的时间却为：2019-04-12 05:29:56 仔细一想，UTC代表的是全球标准时间 ，但是我们使用的时间是北京时区也就是东八区，领先UTC八个小时。所以应该是：UTC + (＋0800) = 本地(北京)时间 解决方案：url的时区使用中国标准时间,因此需要修改时区： serverTimezone=Asia/Shanghai 问题解决！！！————————————————版权声明：本文为CSDN博主「兽医黄小立」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_29129247/article/details/113995811","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"配置篇","slug":"技术篇/配置篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E9%85%8D%E7%BD%AE%E7%AF%87/"},{"name":"报错篇","slug":"技术篇/配置篇/报错篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E9%85%8D%E7%BD%AE%E7%AF%87/%E6%8A%A5%E9%94%99%E7%AF%87/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://wangchuaichuai.github.io/tags/mysql/"},{"name":"连接池","slug":"连接池","permalink":"https://wangchuaichuai.github.io/tags/%E8%BF%9E%E6%8E%A5%E6%B1%A0/"}],"author":"王小欣"},{"title":"彻底解决Could not transfer artifact org.apache.maven.plugins问题","slug":"彻底解决Could not transfer artifact org","date":"2021-11-08T09:20:00.000Z","updated":"2021-11-11T13:00:13.664Z","comments":true,"path":"posts/c3f61ef.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/c3f61ef.html","excerpt":"","text":"彻底解决Could not transfer artifact org.apache.maven.plugins问题彻底解决Could not transfer artifact org.apache.maven.plugins问题之前自己的maven一直下载不了，看过好多博客问题也没法解决，最后自己综合慢慢解决了，现分享一下自己的解决办法： 1、首先保证你的settings配置没问题这里打开File - settings进行路径配置，选择自己的maven路径进行设置。 2、maven中的settings.xml文件中的镜像资源配置&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;!-- junit镜像地址 --&gt; &lt;mirror&gt; &lt;id&gt;junit&lt;/id&gt; &lt;name&gt;junit Address/&lt;/name&gt; &lt;url&gt;http://jcenter.bintray.com/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 配置阿里云的镜像资源。 此时一般问题可以解决，若果不能，请继续： 3、在解压的maven文件夹下将conf文件夹中的settings.xml和toolchains.xml复制过来如图 4、更改idea中的settings设置，解决证书等问题向File - settings中的maven - importing中添加这句-Dmaven.wagon.http.ssl.insecure=true -Dmaven.wagon.http.ssl.allowall=true 能够解决证书问题，如图所示： 到这里基本就ok了如果还不行，再向File - settings中的maven - Runner中添加这句话： -Dmaven.wagon.http.ssl.insecure=true -Dmaven.wagon.http.ssl.allowall=true -Dmaven.wagon.http.ssl.ignore.validity.dates=true -DarchetypeCatalog=internal 如图所示： 成功！！！","categories":[{"name":"配置篇","slug":"配置篇","permalink":"https://wangchuaichuai.github.io/categories/%E9%85%8D%E7%BD%AE%E7%AF%87/"},{"name":"报错篇","slug":"配置篇/报错篇","permalink":"https://wangchuaichuai.github.io/categories/%E9%85%8D%E7%BD%AE%E7%AF%87/%E6%8A%A5%E9%94%99%E7%AF%87/"}],"tags":[{"name":"maven","slug":"maven","permalink":"https://wangchuaichuai.github.io/tags/maven/"},{"name":"工具","slug":"工具","permalink":"https://wangchuaichuai.github.io/tags/%E5%B7%A5%E5%85%B7/"}],"author":"王小欣"},{"title":"react-router v6的一些个人看法","slug":"react-router v6","date":"2021-11-06T09:02:03.000Z","updated":"2021-11-11T12:34:20.790Z","comments":true,"path":"posts/d044eab7.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/d044eab7.html","excerpt":"","text":"react-router的一些个人看法前几天刚刚更新了react-router路由的第六版本的稳定版而且居然全部都是用TS重写，强烈表示好评变化很大，api也变化了很大网上大部分教程还是用着5的版本所以只能硬着头皮去啃下面列出一些自己看文档与演练的一些东西。 Switch更名为Routes Switch里面就是放各个路由Route的，改名为Routes我个人感觉更好理解了 Routes和Link是相对的 这意味着它们会自动构建在父路由的路径和 URL 上 因此您不必手动添加 match.URL 或 match.path 这就导致与有了更好的匹配，代码更加简洁 路由是根据最佳匹配而不是按顺序选择的 可以省略父级的地址直接写子的地址，而且是可以直接嵌套子路由的路由可以嵌套在一个地方，也可以分布在不同的子组件中 Route exact取消了。相反，带有子代路由(在其他组件中定义)的路由在其路径中使用尾随的 * 来表示它们之间有很深的匹配关系Route elementRoute的 render 或 component 改为 element 取消了Redirect5.1中取消了 Redirect ，并且官方推荐在服务器端进行跳转 Route pathv6 简化了 path 的格式，只支持两种动态占位符： :id 样式参数 通配符，只能在 path 的末尾使用，如users/*举个例子正确的path = ‘/groups’path = ‘/groups/admin’path = ‘/users/:id’path = ‘/users/:id/messages’path = ‘/files/‘ // 通配符放在末尾path = ‘/files/:id/‘path = ‘/files-‘不正确的path = ‘/users/:id?’ // ? 不满足上面两种格式path = ‘/tweets/:id(\\d+)’ // 有正则，不满足上面两种格式path = ‘/files//cat.jpg’// 通配符不能放中间 Route index用于表示是否是主路由，如果这个路由设置为true的话，则不能有children Outlet类似于slot插槽的一个东西，可以渲染你的子路由渲染的东西比如这里我定义了一个路由，以及它的两个子路由并且在User组件中定义它的Link，然后放入，来渲染子路由的element所给我们展示的页面 钩子useRoutes上面我们都是把 Route 作为 Routes 的 children但是我们还可以通过useRoutes生成对应的 element import { useRoutes } from ‘react-router-dom’ function App() { const element = useRoutes([ { path: ‘/‘, element: , children: [{ path: ‘auth/‘, element: }, { path: ‘basic/‘, element: } ] } ]) return ( {element} ) } 这种配置项让我们可以清晰地看出路由的嵌套结构 Link state，即点击后可以给 to 传对应的 state Link replace，默认 false，即跳转路由要用 push 还是 replace useNavigateuseHistory 被干掉了，换成了 useNavigate你可以将history.push替换成navigate(to) // v6 navigate(‘/home’); //v5 history.push(‘/home’) // v6 navigate(‘/home’, { replace: true }); //v5 history.replace(‘/home’) useParams以往总是要通过match.params.id来获取一些动态的参数现在可以通过useParams()来获取这些动态变化的参数了","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://wangchuaichuai.github.io/tags/TypeScript/"},{"name":"react-router","slug":"react-router","permalink":"https://wangchuaichuai.github.io/tags/react-router/"},{"name":"react","slug":"react","permalink":"https://wangchuaichuai.github.io/tags/react/"}],"author":"王小欣"},{"title":"uni-app","slug":"uni-app","date":"2021-11-04T04:37:00.000Z","updated":"2021-11-17T10:54:08.999Z","comments":true,"path":"posts/e19785da.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/e19785da.html","excerpt":"","text":"项目搭建(暂不支持vite搭建)1.全局安装 npm install -g @vue/cli 2.创建项目 vue create -p dcloudio/uni-preset-vue 项目名字 3.启动项目(微信小程序) npm run dev:mp-weixin 4.微信小程序开发者工具导入项目 App.vue 应用配置，用来配置App全局样式以及监听main.js Vue初始化入口文件manifest.json 配置应用名称、appid、logo、版本等打包信息pages.json 配置页面路由、导航条、选项卡等页面类信息uni.scss 内置sass变量，可以直接使用 pages index index.vue 页面组件static 静态资源 logo.png 样式和sass1.支持小程序的rpx和h5的vw、vh 2.内置sass的配置，只需要安装依赖即可 npm install sass-loader node-sass 3.vue组件中，在style标签加入属性 &lt;style lang = 'scss'&gt; 全局共享数据通过vue的原型共享数据 Vue.prototype.baseRRL=\"\"; 通过globalData共享数据 微信小程序独有的 getApp().globalData.text = ''; 生命周期uni-app框架的生命周期结合了vue和微信小程序 全局APP中使用onLaunch表示应用启动时 页面中使用onLoad或者onShow分别表示页面加载完毕和页面显示 组件中使用mounted组件挂在完毕 全部的生命周期uni-app https://uniapp.dcloud.io/frame?id=生命周期 vue https://cn.vuejs.org/v2/guide/instance.html?#生命周期图示 微信小程序 https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page-life-cycle.html ​ 全局配置中几个常用的配置## globalStyle ### 属性名字 类型 默认值 描述 ### navigationBarBackgroundColor HexColor #F7F7F7 导航栏背景颜色 ### navigationBarTextStyle String white 导航栏标题颜色，只有black/white ### navigationBarTitleText String 导航栏标题文字内容 ### backgroundColor HexColor #ffffff 窗口的背景色 ### backgroundTextStyle String dark 下拉loading的样式，仅支持dark/light ### enablePullDownRefresh Boolean false 是否开启下拉刷新 ### onReachBottomDistance Number 50 上拉触底事件触发的距离，单位只支持px condition启动模式配置 启动模式配置，仅开发期间生效，用于模拟直达页面的场景 current Number 是 当前激活的模式，list节点的索引值list Array 是 启动模式列表 list说明 name String 是 启动模式名称 path String 是 启动页面路径 query String 否 启动参数，可在页面的onload函数里获得 uni-app中的样式## 使用@import语句可以导入外联样式表，@import后需要导外联央视的相对路径，用;结束 # 传参 ## 定义函数后，函数中传参，获取参数，如果传递$event,则可以拿e去获取事件对象 # 生命周期 ## onLaunch 初始化完成时触发，全局触发一次 ## onShow 启动后，或从后台进入前台显示 ## onHide 从前台进入后台 ## onError 报错触发 # 页面生命周期 ## onLoad 监听页面加载，参数为上个页面传递的数据 ## onShow 监听页面显示，包括从下级页面点返回露出当前页面 ## onReady 初次渲染完成 ## onHide 监听页面隐藏 ## onUnload 监听页面卸载 # 下拉刷新 ## 不推荐全局配置，应该哪个页面需要配置哪个 ### 在pages.json中找到pages节点，在页面中添加style，开启enablePullDownRefresh ### 当处理完数据后，uni.stopPullDownRefresh可以停止刷新 # get请求 ## uni.request(Object) # 数据缓存 ## uni.setStorage(Object) ### key String 是 本地缓存中指定的key ### data any 是 存储的内容 ### success function 否 接口调用成功的回调函数 ### fail function 否 失败的回调函数 ### complete function 否 调用结束的回调函数 # 条件注释 ## 实现用特殊注释作为标记，根据特殊的注释编译到不同平台 ### 写法: #### #ifdef开头，#endif结尾","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"学习篇","slug":"技术篇/学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"},{"name":"uni-app","slug":"uni-app","permalink":"https://wangchuaichuai.github.io/tags/uni-app/"}],"author":"王小欣"},{"title":"TypeScript","slug":"TS的一些基本用法","date":"2021-11-02T09:02:03.000Z","updated":"2021-11-11T12:33:55.334Z","comments":true,"path":"posts/e3e08109.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/e3e08109.html","excerpt":"","text":"安装TSnpm install -g typescript tsc -V 检查版本安装是否完成 引入别与js的语法html中直接引入ts文件，如果ts文件中只有单纯的js的语法代码，是可以正常引入和使用的，如果使用了ts的语法则会报错 ts文件中的函数中的形参，如果使用了某个类型进行修饰，那么最终编译的js文件中是没有这个类型的 终端: tsc ts文件，则会自动把ts编译为js文件 利用vscode自动把ts编译为js1.在项目中使用 tsc --init 2.修改tsconfig.json文件 \"outDir\":\"./目录\" 将编译后的js文件存放的目录 \"strict\":false 将严格模式关闭 3.启动监视任务 终端-&gt;运行任务-&gt;监视tsconfig.json 类型注解:是一种轻量级的为函数或者变量添加的约束ps：ts种变量一开始是什么类型，那么后期赋值的适合，只能用这个类型的数据，是不允许用其他类型的数据赋值给当前的这个变量种 如: let str : string = \"王欣\" str = 10 报错 但是undefined和null两种类型都可以作为其他类型的子类型，把undefined和null赋值给其他类型的变量 如: let num : number = underfined console.log(num) 是不会报错的 如果报错，则关闭严格模式 数组基本的 //数组写法 let 名字 :number[] = [10,21] //泛型写法 let 名字 :Array&lt;number&gt; = [10,21] ps:数组定义后，里面的数据类型和定义数组时候的数据类型必须是一致的，否则会有错误提示也不会编译通过 元组：在定义数组的时候，类型和数据的个数一开始就定好了， 位置也是定死的 //元组写法 let arr3 : [string,number] = ['小小',20] 枚举枚举里面的每一个数据值都可以叫元素，标号从0开始递增1 enum Color{ red,green,blue } let color:Color = Color.red any类型let str:any = 100 str = '年少不知富婆好' //当一个数组种要存储多个数据，个数和类型不确 联合类型传参用 | 分开 function (str:number | String){} 类型断言告诉编译器，解决编译时期的报错 第一种写法:&lt;类型&gt;变量名 第二种写法:值 as 类型 接口interfaceinterface Iperson{ readonly id: number//readonly代表只读 name:string age:number sex?:string//?代表可有可无 } 函数中的可选和默认参数可选参数:函数在声明的时候，内部的参数使用了?进行修饰，那么就表示该参数可以传入野可以不用传入 默认参数:在声明的时候，内部有自己的默认值 剩余参数(rest参数)放在函数声明的时候所有参数的最后 (()=&gt;{ function showMsg(str:string,str2:string,...args:string[]){ } showMsg('a','b','c','d') })() 函数重载要判断参数的类型是否一致 //先进行重载函数的声明 function add(str1:string,str2:string):string function add(str1:number,str2:number):number //在进行函数声明 function add(str1:string | number,str2:string|number):string | number{ if (typeof str1 === 'string' &amp;&amp; typeof str2 === 'string'){ return x+y }else if(typeof str1 === 'number' &amp;&amp; typeof str2 === 'number') return x+y } TS检视工具TSLint在工厂package.json文件中配置TSLint包 \"devDependencies\":{ \"tslint\":\"版本号\", \"tslint-config-airbnb\":\"版本号\", \"tslint-react\":\"版本号\" } 在更目录中的tslint.json文件中可以根据需要配置已有的规则 在完成工程配置后需要下载所需要的依赖包npm i 对于react native工程 执行命令来检查 tslint --project tsconfig.json --config tslint.json","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://wangchuaichuai.github.io/tags/TypeScript/"}],"author":"王小欣"},{"title":"Git","slug":"git的一些基础用法","date":"2021-11-01T08:21:13.000Z","updated":"2021-11-11T12:35:08.503Z","comments":true,"path":"posts/d74d8b76.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/d74d8b76.html","excerpt":"","text":"聊聊git历史同生活中的许多伟大事物一样，Git诞生于一个极富纷争大局创新的时代。 Linux内核开源项目有着为数众广的参与者。 绝大多数的Linux内核维护工作都花在了提交补丁和保存归档的繁琐事务上(1991-2002年间)。 到2002年，整个项目组开始启用一个专有的分布式版本控制系统BitKeeper来管理和维护代码。 到了2005年，开发BitKeeper的商业公司同Linux内核开源社区的合作关系结束 他们收回了Linux内核社区免费使用BitKeeper的权利 这就迫使Linux开源社区(特别是Linux的缔造者Linus Torvalds)基于使用BitKeeper时的经验教训， 开发出自己的版本系统。也就是后来的Git！ Git是目前世界上最先进的分布式版本控制系统 Git是免费的、开源的、最初Git是为了辅助Linux内核开发的，用来替代BitKeeper！ Git环境配置 打开[git官网](https://git-scm.com),下载git对应操作系统的版本 官网下载太慢，可以用淘宝镜像下载: http://npm.taobao.org/mirrors/git-for-windows/ 下载对应的版本即可安装！ 无脑下一步~~ 启动Git安装成功后在开始菜单中会有Git项，菜单下有3个程序: Git Bash:Unix与Linux风格的命令行，使用最多，推荐最多 Git CMD:windows风格的命令行 Git GUI:图形界面的Git，不建议初学者使用，尽量先熟悉常用命令 基本的Linux命令学习 [1] cd:改变目录 [2] cd ../回退到上一个目录 [3] pwd:显示当前所在目录的路径 [4] ls(ll):都是列出当前目录中的所有文件,只不过ll列出的内容更加详细 [5] touch:新建一个文件 [6] rm:删除一个文件 [7] mkdir:新建一个文件夹或目录 [8] rm -r:删除一个文件夹 [9] mv:移动文件mv index.js src index.js是要移动的文件，src是目标文件夹， ​ 当然，这样写必须保证文件和目标文件夹在同一目录下 [10] reset:重新初始化终端/清屏 [11] clear:清屏 [12] history:查看命令历史 [13] help:帮助 [14] exit:退出 [15] 方向键(上下):执行过的上一条命令和下一条命令 [16] #表示注释 Git配置查看配置 git config -l 查看不同级别的配置文件 #查看系统config git config –system –list #查看当前用户(global)配置 git config --global --list Git相关的配置文件: - [1] Git\\mingw64\\etc\\gitconfig:Git安装目录下的gitconfig –system系统级 - [2] C:\\Users\\Administrator.gitconfig 只适用于当前登录用户的配置 –global全局这里可以直接编辑配置文件，通过命令设置后会响应到这里 Git项目搭建 创建工作目录与常用指令 工作目录(workspace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，页可以是一个空目录，建议不要有中文。 本地仓库搭建 创建本地仓库的方法有两种:一个是创建全新的仓库，另一个是克隆远程仓库 - [1] 创建全新的仓库，需要用GIT管理的项目的根目录执行: # 在当前目录新建一个git代码库 $ git init - [2] 执行后可以看到，项目目录中多了一个.git目录 克隆远程仓库 克隆远程仓库 - [1] 克隆 - # 克隆一个项目和它的整个代码历史(版本信息) - $ git clone [url]","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"}],"tags":[{"name":"git","slug":"git","permalink":"https://wangchuaichuai.github.io/tags/git/"},{"name":"命令","slug":"命令","permalink":"https://wangchuaichuai.github.io/tags/%E5%91%BD%E4%BB%A4/"}],"author":"王小欣"},{"title":"单页面程序SPA的优劣","slug":"单页面程序","date":"2021-10-29T04:37:00.000Z","updated":"2021-11-17T10:10:18.544Z","comments":true,"path":"posts/da0536b5.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/da0536b5.html","excerpt":"","text":"单页面程序的优点## 1.良好的交互体验 单页面应用的内容的改变不需要重新加载整个页面 获取数据也是通过ajax异步获取 没有页面之间的跳转，不会白屏 ## 2.良好的前后端工作分离模式 后端专注于提供API接口，更易于实现API接口的复用 前端专注于页面的渲染，更利于前端工程化的发展 ## 3.减轻服务器的压力 服务器只提供数据，不负责页面的合成与逻辑的处理，吞吐能力会提高几倍 单页面的缺点## 1.首屏加载慢 解决方法 路由懒加载 代码压缩 CDN加速 网络传输压缩 #3 2.不利于SEO 解决方法 SSR服务器端渲染","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"学习篇","slug":"技术篇/学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"},{"name":"SPA单页面程序","slug":"SPA单页面程序","permalink":"https://wangchuaichuai.github.io/tags/SPA%E5%8D%95%E9%A1%B5%E9%9D%A2%E7%A8%8B%E5%BA%8F/"}],"author":"王小欣"},{"title":"props","slug":"props","date":"2021-10-28T04:37:00.000Z","updated":"2021-11-17T10:10:18.541Z","comments":true,"path":"posts/5b7eaaa8.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/5b7eaaa8.html","excerpt":"","text":"props组件的自定义属性使用者可以通过props把数据传递到子组件的内部，供子组件进行使用 &lt;my-article title=\"面朝大海\" author=\"海子\"/&gt; 作用：父组件通过props向子组件传递要展示的数据 好处：提高了组件的复用性 export default{ props:['title','author'], //在props节点中用数组声明 } 行内绑定动态sytle样式用:style 绑定class动态的用:class，如果有多个事件的改变，再创建一个数据，绑定数据 &lt;div :class=\"classObj\"&gt;&lt;/div&gt; &lt;script&gt; export default{ data(){ return{ classObj:{ a:false, b:true } } } } &lt;/script&gt; props验证再封装组件时对外界传递过来的props数据进行合法性的校验，从而防止数据不合法的问题 使用数组类型的props节点的缺点：无法为每个prop指定具体的数据类型 1.改进：让props指向一个对象而不是数组 props:{ count:Number, state:Boolean } 2.若prop属性值的类型不唯一，此时可以通过数组的形式，为其指定多个属性值 export default{ props:{ propA:[String,Number], } } 3.组件的某个porp属性是必填项，指定其为true表示为必填项 export default{ props:{ propB:{ type:String, required:true, } } } 4.属性的默认值,例子中默认值为aaa export default{ props:{ propB:{ type:String, required:true, default:\"aaa\" } } } 5.自定义验证函数 export default{ props:{ propD:{//用validator函数去定义自定义的验证函数，用value接收传递过来的数据 validator(value){ //传递的参数value必须匹配字符串的任意一个，如果匹配则validator返回值是true否则是false return['success','warning'].indexOf(value) !== -1 } } } }","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"学习篇","slug":"技术篇/学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"},{"name":"props","slug":"props","permalink":"https://wangchuaichuai.github.io/tags/props/"}],"author":"王小欣"},{"title":"前端路由","slug":"前端路由","date":"2021-10-27T04:37:00.000Z","updated":"2021-11-17T10:54:09.005Z","comments":true,"path":"posts/e439c1da.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/e439c1da.html","excerpt":"","text":"路由路由分为前端路由和后端路由 后端路由 请求方式、请求地址与function处理函数之间的对应关系 SPA与前端路由 SPA中更新页面是组件的切换，不同组件之间的切换需要通过前端路由来实现 前端路由的工作方法1.用户点击了页面上的路由连接 2.导致了URL地址栏中的Hash值发生了变化 3.前端路由监听到了Hash地址的变化 4.前端路由把当前Hash地址对应的组件渲染到浏览器中 实现简易的前端路由的步骤(最基础的实现步骤)1.导入并注册组件 2.通过&lt;component&gt;标签的is属性，动态切换要显示的组件 3.在组件的结构中声明&lt;a&gt;连接，点击不同的连接切换地址栏中的Hash值 4.在created生命周期函数中监听浏览器地址栏中Hash地址的变化，动态切换要展示的组件的名称 通过window.onhashchange函数来获取Hash值的变化 实际开发的前端路由(vue-router)vue-router目前有3.x和4.x的版本 vue-router3.x只能结合vue2使用 https://router.vuejs.org/zh/ vue-router4.x只能结合vue3使用 https://next.router.vuejs.org/ 使用vue-router4.x基本使用步骤1.在项目中安装vue-router npm install vue-router@next -S 2.定义路由组件 3.声明路由链接和占位符 可以使用&lt;router-link&gt;标签来声明路由链接，并使用&lt;router-view&gt;标签来声明路由占位符 用to属性来替代a链接的href链接,并且不用写Hash地址的# &lt;router-link to=\"/home\"&gt;首页&lt;/router-link&gt; 4.创建路由模块 在项目中创建router.js路由模块，在其中按照步骤配置并得到实例对象 1.从vue-router中按需导入两个方法 createRouter方法用于创建路由的实例对象 createWebHashHistory用于指定路由的工作模式(hash模式) import{ createRouter,createWebHashHistory } from 'vue-router' 2.导入需要使用路由控制的组件 3.创建路由实例对象 //创建路由实例对象 const router = createRouter({ //通过history属性指定路由的工作模式 history:createWebHashHistory(), //通过routes数组，指定路由规则 routes:[ //path是hash地址，component是要展示的组件 {path:'/home',component:Home}, ], }) 4.向外共享路由实例对象 5.在main.js中导入并挂在路由模块 创建对象后，用use方法挂在路由，固定写法 const app = createApp(App) app.use(router) app.mount('#app') 5.导入并挂在路由模块","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"学习篇","slug":"技术篇/学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"},{"name":"router","slug":"router","permalink":"https://wangchuaichuai.github.io/tags/router/"}],"author":"王小欣"},{"title":"ref","slug":"组件-Ref引用","date":"2021-10-26T04:37:00.000Z","updated":"2021-11-17T11:16:43.696Z","comments":true,"path":"posts/146f3ea3.html","link":"","permalink":"https://wangchuaichuai.github.io/posts/146f3ea3.html","excerpt":"","text":"ref引用ref用来辅助开发者在不依赖jQuery的情况下，获取DOM元素或组件的引用 每个vue的组件实例上，都包含一个$refs对象，里面存储者对应的DOM元素或组件的引用 默认情况下，每个组件的$refs指向一个空对象 ref在DOM更新之后执行操作this.$nextTick(cb)方法 会把cb回调推迟到下一个DOM更新周期之后执行 通俗理解为：等组件DOM异步的重新渲染完成后再执行cb回调函数 从而保证回调函数可以操作到最新的DOM元素 动态更新组件使用component标签，属性用is赋值，可以用v-bind绑定值 使用keep-alive保持状态默认情况下，切换动态组件时无法保持组件的状态，此时可以使用vue内置的&lt;keep-alive&gt;组件保持动态组件的状态 &lt;keep-alive&gt; &lt;component :is=\"comName\"&gt;&lt;/component&gt; &lt;/keep-alive&gt;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"学习篇","slug":"技术篇/学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"},{"name":"ref","slug":"ref","permalink":"https://wangchuaichuai.github.io/tags/ref/"}],"author":"王小欣"}],"categories":[{"name":"问题篇","slug":"问题篇","permalink":"https://wangchuaichuai.github.io/categories/%E9%97%AE%E9%A2%98%E7%AF%87/"},{"name":"配置篇","slug":"问题篇/配置篇","permalink":"https://wangchuaichuai.github.io/categories/%E9%97%AE%E9%A2%98%E7%AF%87/%E9%85%8D%E7%BD%AE%E7%AF%87/"},{"name":"技术篇","slug":"技术篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"学习篇","slug":"技术篇/学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AF%87/"},{"name":"学习篇","slug":"学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"},{"name":"配置篇","slug":"学习篇/配置篇","permalink":"https://wangchuaichuai.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/%E9%85%8D%E7%BD%AE%E7%AF%87/"},{"name":"配置篇","slug":"配置篇","permalink":"https://wangchuaichuai.github.io/categories/%E9%85%8D%E7%BD%AE%E7%AF%87/"},{"name":"配置篇","slug":"技术篇/配置篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E9%85%8D%E7%BD%AE%E7%AF%87/"},{"name":"报错篇","slug":"技术篇/报错篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E6%8A%A5%E9%94%99%E7%AF%87/"},{"name":"学习篇","slug":"技术篇/报错篇/学习篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E6%8A%A5%E9%94%99%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AF%87/"},{"name":"报错篇","slug":"技术篇/配置篇/报错篇","permalink":"https://wangchuaichuai.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/%E9%85%8D%E7%BD%AE%E7%AF%87/%E6%8A%A5%E9%94%99%E7%AF%87/"},{"name":"报错篇","slug":"配置篇/报错篇","permalink":"https://wangchuaichuai.github.io/categories/%E9%85%8D%E7%BD%AE%E7%AF%87/%E6%8A%A5%E9%94%99%E7%AF%87/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wangchuaichuai.github.io/tags/vue/"},{"name":"eslint","slug":"eslint","permalink":"https://wangchuaichuai.github.io/tags/eslint/"},{"name":"threejs","slug":"threejs","permalink":"https://wangchuaichuai.github.io/tags/threejs/"},{"name":"3D可视化","slug":"3D可视化","permalink":"https://wangchuaichuai.github.io/tags/3D%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"name":"3D","slug":"3D","permalink":"https://wangchuaichuai.github.io/tags/3D/"},{"name":"nestjs","slug":"nestjs","permalink":"https://wangchuaichuai.github.io/tags/nestjs/"},{"name":"nodejs","slug":"nodejs","permalink":"https://wangchuaichuai.github.io/tags/nodejs/"},{"name":"加密","slug":"加密","permalink":"https://wangchuaichuai.github.io/tags/%E5%8A%A0%E5%AF%86/"},{"name":"react","slug":"react","permalink":"https://wangchuaichuai.github.io/tags/react/"},{"name":"组件","slug":"组件","permalink":"https://wangchuaichuai.github.io/tags/%E7%BB%84%E4%BB%B6/"},{"name":"打包","slug":"打包","permalink":"https://wangchuaichuai.github.io/tags/%E6%89%93%E5%8C%85/"},{"name":"css","slug":"css","permalink":"https://wangchuaichuai.github.io/tags/css/"},{"name":"React","slug":"React","permalink":"https://wangchuaichuai.github.io/tags/React/"},{"name":"hooks","slug":"hooks","permalink":"https://wangchuaichuai.github.io/tags/hooks/"},{"name":"typescript","slug":"typescript","permalink":"https://wangchuaichuai.github.io/tags/typescript/"},{"name":"JS","slug":"JS","permalink":"https://wangchuaichuai.github.io/tags/JS/"},{"name":"axios","slug":"axios","permalink":"https://wangchuaichuai.github.io/tags/axios/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://wangchuaichuai.github.io/tags/JavaScript/"},{"name":"QA","slug":"QA","permalink":"https://wangchuaichuai.github.io/tags/QA/"},{"name":"算法","slug":"算法","permalink":"https://wangchuaichuai.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"elementUI","slug":"elementUI","permalink":"https://wangchuaichuai.github.io/tags/elementUI/"},{"name":"移动端","slug":"移动端","permalink":"https://wangchuaichuai.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"html","slug":"html","permalink":"https://wangchuaichuai.github.io/tags/html/"},{"name":"PWA","slug":"PWA","permalink":"https://wangchuaichuai.github.io/tags/PWA/"},{"name":"跨域","slug":"跨域","permalink":"https://wangchuaichuai.github.io/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"http","slug":"http","permalink":"https://wangchuaichuai.github.io/tags/http/"},{"name":"vant","slug":"vant","permalink":"https://wangchuaichuai.github.io/tags/vant/"},{"name":"vue-router","slug":"vue-router","permalink":"https://wangchuaichuai.github.io/tags/vue-router/"},{"name":"ElementUI","slug":"ElementUI","permalink":"https://wangchuaichuai.github.io/tags/ElementUI/"},{"name":"composition","slug":"composition","permalink":"https://wangchuaichuai.github.io/tags/composition/"},{"name":"特性","slug":"特性","permalink":"https://wangchuaichuai.github.io/tags/%E7%89%B9%E6%80%A7/"},{"name":"插槽","slug":"插槽","permalink":"https://wangchuaichuai.github.io/tags/%E6%8F%92%E6%A7%BD/"},{"name":"导航","slug":"导航","permalink":"https://wangchuaichuai.github.io/tags/%E5%AF%BC%E8%88%AA/"},{"name":"宏任务","slug":"宏任务","permalink":"https://wangchuaichuai.github.io/tags/%E5%AE%8F%E4%BB%BB%E5%8A%A1/"},{"name":"微任务","slug":"微任务","permalink":"https://wangchuaichuai.github.io/tags/%E5%BE%AE%E4%BB%BB%E5%8A%A1/"},{"name":"ES6","slug":"ES6","permalink":"https://wangchuaichuai.github.io/tags/ES6/"},{"name":"规范","slug":"规范","permalink":"https://wangchuaichuai.github.io/tags/%E8%A7%84%E8%8C%83/"},{"name":"Less","slug":"Less","permalink":"https://wangchuaichuai.github.io/tags/Less/"},{"name":"yield","slug":"yield","permalink":"https://wangchuaichuai.github.io/tags/yield/"},{"name":"Redux","slug":"Redux","permalink":"https://wangchuaichuai.github.io/tags/Redux/"},{"name":"Redux-saga","slug":"Redux-saga","permalink":"https://wangchuaichuai.github.io/tags/Redux-saga/"},{"name":"路由动画","slug":"路由动画","permalink":"https://wangchuaichuai.github.io/tags/%E8%B7%AF%E7%94%B1%E5%8A%A8%E7%94%BB/"},{"name":"mobx","slug":"mobx","permalink":"https://wangchuaichuai.github.io/tags/mobx/"},{"name":"linux","slug":"linux","permalink":"https://wangchuaichuai.github.io/tags/linux/"},{"name":"mysql","slug":"mysql","permalink":"https://wangchuaichuai.github.io/tags/mysql/"},{"name":"react-router","slug":"react-router","permalink":"https://wangchuaichuai.github.io/tags/react-router/"},{"name":"连接池","slug":"连接池","permalink":"https://wangchuaichuai.github.io/tags/%E8%BF%9E%E6%8E%A5%E6%B1%A0/"},{"name":"maven","slug":"maven","permalink":"https://wangchuaichuai.github.io/tags/maven/"},{"name":"工具","slug":"工具","permalink":"https://wangchuaichuai.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://wangchuaichuai.github.io/tags/TypeScript/"},{"name":"uni-app","slug":"uni-app","permalink":"https://wangchuaichuai.github.io/tags/uni-app/"},{"name":"git","slug":"git","permalink":"https://wangchuaichuai.github.io/tags/git/"},{"name":"命令","slug":"命令","permalink":"https://wangchuaichuai.github.io/tags/%E5%91%BD%E4%BB%A4/"},{"name":"SPA单页面程序","slug":"SPA单页面程序","permalink":"https://wangchuaichuai.github.io/tags/SPA%E5%8D%95%E9%A1%B5%E9%9D%A2%E7%A8%8B%E5%BA%8F/"},{"name":"props","slug":"props","permalink":"https://wangchuaichuai.github.io/tags/props/"},{"name":"router","slug":"router","permalink":"https://wangchuaichuai.github.io/tags/router/"},{"name":"ref","slug":"ref","permalink":"https://wangchuaichuai.github.io/tags/ref/"}]}